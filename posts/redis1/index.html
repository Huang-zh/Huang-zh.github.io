<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="[huangzh]">
<meta name="description" content="1. 前言  2022年，是充满挑战性的一年。
这一年，我选择离开了自己熟悉的信息化领域，把精力投向了互联网金融。
在22年的后半程，鉴于平台和团队所带来的效应，个人也在高频交易业务领域吸收了足够多的知识。过程中，认知的颠覆和自我的怀疑常常是共存。
所幸这些经历最后都能够作为养分，支撑我一步步走到当下。
这个系列的文章，初稿实际上在22年的年底就已经完成。但碍于平日里事务繁忙兼琐事繁多，使得日子一再蹉跎，一直推迟到23年过半，才开始尝试去重新梳理其中的些许细节，并准备将它发表在博客里。
初稿原本诞生于22年在高频交易系统的技术选型、架构搭建和研发过程中。当时和团队里优秀的工程师们对redis尝试不断地深入探索，试图吸收其在架构设计方面的优点，并思考对于交易业务领域可以如何进行二次开发以达到发挥极致性能的目的，从而形成了这份初稿。当然，由于保密机制，文档中原先存在的定制化方案和敏感信息已去除，但对redis架构有兴趣的朋友，仍然可以通过这个系列洞悉redis在设计方面的优点。
过程中难免会因为篇幅原因删除细枝末节的代码，这也是为更好的去掌握主流程，让整个文档脉络更清晰而做的取舍。若对内容有异议，可通过邮箱联系我。
 huangzh 2023.08.25    阅读本文档存在一些门槛，不建议新手直接阅读，建议大家先掌握以下必要的技能：  良好的c语言基础。 掌握多路复用编程网络模型。 对操作系统中io的认知。 学习并调试过其他常用中间件代码的经验。 耐心。   redis的存储模型，是典型的hash存储。即一个key对应一个或多个值，这在redis支持的数据类型有着明确的体现，redis一共支持五种类型的数据结构存储：
 string hash（又称为set） list zset zlist  从广义上来看，这五种类型数据的存储都可以用key-value形式去实现，无非是value所对应的值的形式有所不同。
 2. hash存储引擎 提到redis，不得不先提及hash存储引擎的概念，一个典型的hash存储引擎原理如下图所示：
这种基于hash的存储方式，与传统关系性数据库有着非常大的区别。
在内存中通过一定的hash算法均匀的散列key值，使不同的key均匀的散落在hashtable的不同栏位。
由于相同的key可能对应不同的value，因此hashtable每个栏位实际上采用挂载链表的形式存储每一个value节点。
每个value节点中，包含三个最重要的元素：
 position：value的起始位置 size：value对应的长度 fileid：value存储的文件标识符  当然，节点中当然可以包含其他额外的值，不同软件有着自己的额外添加的元素。
但是，不约而外的，通过这三个必要的元素，可以找到key对应的value究竟存储于哪个文件，以及value在该文件中对应的起始位置和长度。
通过这种方式，实际上可以很方便的查找key-value元素。同时，这种方式将hashtable中每个栏位的写入由随机写（hash值随机）转变为顺序写（每个栏位的数据只需要顺序往该栏位对应的文件中添加即可，通过节点链表顺序连接），大大提高了写入的效率。
同时，使用hash存储引擎还存在以下特点：
 时间复杂度o(1)。 满足“=”，“IN”条件查询。 不支持范围查询，比如between关键字。 不支持order by关键字排序。   3. redis数据模型 我们在描述一种存储类型的中间件时，无论它是缓存类的存储，亦或是传统写入磁盘的关系性数据库存储，都存在它们各自最基础也是最核心的数据存储模型，这里我个人习惯把它叫做数据模型，基于数据模型才能实现上层复杂的结构存储。
redis的数据模型，可以把它看成字典，一种基于key-value存储的数据结构，底层由数组实现的基于hashtable的拉链法存储。
以下是从redis源码中提取的四种以此从外到内的核心数据模型，其中redisDb为最外层，抽丝剥茧之后，不难发现真正的数据存储于底层的dictEntry：
typedef struct redisDb { dict *dict; /* The keyspace for this DB */ dict *expires; /* Timeout of keys with a timeout set */ dict *blocking_keys; /* Keys with clients waiting for data (BLPOP)*/ dict *ready_keys; /* Blocked keys that received a PUSH */ dict *watched_keys; /* WATCHED keys for MULTI/EXEC CAS */ int id; /* Database ID */ long long avg_ttl; /* Average TTL, just for stats */ list *defrag_later; /* List of key names to attempt to defrag one by one, gradually." />
<meta name="keywords" content=", redis" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="https://Huang-zh.github.io/posts/redis1/" />


    <title>
        
            Redis存储原理剖析&lt;一&gt;：存储模型和基础命令解析 :: 此间的少年 
        
    </title>





<link rel="stylesheet" href="/main.b78c3be9451dc4ca61ca377f3dc2cf2e6345a44c2bae46216a322ef366daa399.css" integrity="sha256-t4w76UUdxMphyjd/PcLPLmNFpEwrrkYhajIu82bao5k=">



    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
    <link rel="shortcut icon" href="/favicon.ico">
    <meta name="msapplication-TileColor" content="">


<meta itemprop="name" content="Redis存储原理剖析&lt;一&gt;：存储模型和基础命令解析">
<meta itemprop="description" content="1. 前言  2022年，是充满挑战性的一年。
这一年，我选择离开了自己熟悉的信息化领域，把精力投向了互联网金融。
在22年的后半程，鉴于平台和团队所带来的效应，个人也在高频交易业务领域吸收了足够多的知识。过程中，认知的颠覆和自我的怀疑常常是共存。
所幸这些经历最后都能够作为养分，支撑我一步步走到当下。
这个系列的文章，初稿实际上在22年的年底就已经完成。但碍于平日里事务繁忙兼琐事繁多，使得日子一再蹉跎，一直推迟到23年过半，才开始尝试去重新梳理其中的些许细节，并准备将它发表在博客里。
初稿原本诞生于22年在高频交易系统的技术选型、架构搭建和研发过程中。当时和团队里优秀的工程师们对redis尝试不断地深入探索，试图吸收其在架构设计方面的优点，并思考对于交易业务领域可以如何进行二次开发以达到发挥极致性能的目的，从而形成了这份初稿。当然，由于保密机制，文档中原先存在的定制化方案和敏感信息已去除，但对redis架构有兴趣的朋友，仍然可以通过这个系列洞悉redis在设计方面的优点。
过程中难免会因为篇幅原因删除细枝末节的代码，这也是为更好的去掌握主流程，让整个文档脉络更清晰而做的取舍。若对内容有异议，可通过邮箱联系我。
 huangzh 2023.08.25    阅读本文档存在一些门槛，不建议新手直接阅读，建议大家先掌握以下必要的技能：  良好的c语言基础。 掌握多路复用编程网络模型。 对操作系统中io的认知。 学习并调试过其他常用中间件代码的经验。 耐心。   redis的存储模型，是典型的hash存储。即一个key对应一个或多个值，这在redis支持的数据类型有着明确的体现，redis一共支持五种类型的数据结构存储：
 string hash（又称为set） list zset zlist  从广义上来看，这五种类型数据的存储都可以用key-value形式去实现，无非是value所对应的值的形式有所不同。
 2. hash存储引擎 提到redis，不得不先提及hash存储引擎的概念，一个典型的hash存储引擎原理如下图所示：
这种基于hash的存储方式，与传统关系性数据库有着非常大的区别。
在内存中通过一定的hash算法均匀的散列key值，使不同的key均匀的散落在hashtable的不同栏位。
由于相同的key可能对应不同的value，因此hashtable每个栏位实际上采用挂载链表的形式存储每一个value节点。
每个value节点中，包含三个最重要的元素：
 position：value的起始位置 size：value对应的长度 fileid：value存储的文件标识符  当然，节点中当然可以包含其他额外的值，不同软件有着自己的额外添加的元素。
但是，不约而外的，通过这三个必要的元素，可以找到key对应的value究竟存储于哪个文件，以及value在该文件中对应的起始位置和长度。
通过这种方式，实际上可以很方便的查找key-value元素。同时，这种方式将hashtable中每个栏位的写入由随机写（hash值随机）转变为顺序写（每个栏位的数据只需要顺序往该栏位对应的文件中添加即可，通过节点链表顺序连接），大大提高了写入的效率。
同时，使用hash存储引擎还存在以下特点：
 时间复杂度o(1)。 满足“=”，“IN”条件查询。 不支持范围查询，比如between关键字。 不支持order by关键字排序。   3. redis数据模型 我们在描述一种存储类型的中间件时，无论它是缓存类的存储，亦或是传统写入磁盘的关系性数据库存储，都存在它们各自最基础也是最核心的数据存储模型，这里我个人习惯把它叫做数据模型，基于数据模型才能实现上层复杂的结构存储。
redis的数据模型，可以把它看成字典，一种基于key-value存储的数据结构，底层由数组实现的基于hashtable的拉链法存储。
以下是从redis源码中提取的四种以此从外到内的核心数据模型，其中redisDb为最外层，抽丝剥茧之后，不难发现真正的数据存储于底层的dictEntry：
typedef struct redisDb { dict *dict; /* The keyspace for this DB */ dict *expires; /* Timeout of keys with a timeout set */ dict *blocking_keys; /* Keys with clients waiting for data (BLPOP)*/ dict *ready_keys; /* Blocked keys that received a PUSH */ dict *watched_keys; /* WATCHED keys for MULTI/EXEC CAS */ int id; /* Database ID */ long long avg_ttl; /* Average TTL, just for stats */ list *defrag_later; /* List of key names to attempt to defrag one by one, gradually."><meta itemprop="datePublished" content="2023-08-25T22:10:44+08:00" />
<meta itemprop="dateModified" content="2023-08-25T22:10:44+08:00" />
<meta itemprop="wordCount" content="1135"><meta itemprop="image" content="https://Huang-zh.github.io"/>
<meta itemprop="keywords" content="redis," />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://Huang-zh.github.io"/>

<meta name="twitter:title" content="Redis存储原理剖析&lt;一&gt;：存储模型和基础命令解析"/>
<meta name="twitter:description" content="1. 前言  2022年，是充满挑战性的一年。
这一年，我选择离开了自己熟悉的信息化领域，把精力投向了互联网金融。
在22年的后半程，鉴于平台和团队所带来的效应，个人也在高频交易业务领域吸收了足够多的知识。过程中，认知的颠覆和自我的怀疑常常是共存。
所幸这些经历最后都能够作为养分，支撑我一步步走到当下。
这个系列的文章，初稿实际上在22年的年底就已经完成。但碍于平日里事务繁忙兼琐事繁多，使得日子一再蹉跎，一直推迟到23年过半，才开始尝试去重新梳理其中的些许细节，并准备将它发表在博客里。
初稿原本诞生于22年在高频交易系统的技术选型、架构搭建和研发过程中。当时和团队里优秀的工程师们对redis尝试不断地深入探索，试图吸收其在架构设计方面的优点，并思考对于交易业务领域可以如何进行二次开发以达到发挥极致性能的目的，从而形成了这份初稿。当然，由于保密机制，文档中原先存在的定制化方案和敏感信息已去除，但对redis架构有兴趣的朋友，仍然可以通过这个系列洞悉redis在设计方面的优点。
过程中难免会因为篇幅原因删除细枝末节的代码，这也是为更好的去掌握主流程，让整个文档脉络更清晰而做的取舍。若对内容有异议，可通过邮箱联系我。
 huangzh 2023.08.25    阅读本文档存在一些门槛，不建议新手直接阅读，建议大家先掌握以下必要的技能：  良好的c语言基础。 掌握多路复用编程网络模型。 对操作系统中io的认知。 学习并调试过其他常用中间件代码的经验。 耐心。   redis的存储模型，是典型的hash存储。即一个key对应一个或多个值，这在redis支持的数据类型有着明确的体现，redis一共支持五种类型的数据结构存储：
 string hash（又称为set） list zset zlist  从广义上来看，这五种类型数据的存储都可以用key-value形式去实现，无非是value所对应的值的形式有所不同。
 2. hash存储引擎 提到redis，不得不先提及hash存储引擎的概念，一个典型的hash存储引擎原理如下图所示：
这种基于hash的存储方式，与传统关系性数据库有着非常大的区别。
在内存中通过一定的hash算法均匀的散列key值，使不同的key均匀的散落在hashtable的不同栏位。
由于相同的key可能对应不同的value，因此hashtable每个栏位实际上采用挂载链表的形式存储每一个value节点。
每个value节点中，包含三个最重要的元素：
 position：value的起始位置 size：value对应的长度 fileid：value存储的文件标识符  当然，节点中当然可以包含其他额外的值，不同软件有着自己的额外添加的元素。
但是，不约而外的，通过这三个必要的元素，可以找到key对应的value究竟存储于哪个文件，以及value在该文件中对应的起始位置和长度。
通过这种方式，实际上可以很方便的查找key-value元素。同时，这种方式将hashtable中每个栏位的写入由随机写（hash值随机）转变为顺序写（每个栏位的数据只需要顺序往该栏位对应的文件中添加即可，通过节点链表顺序连接），大大提高了写入的效率。
同时，使用hash存储引擎还存在以下特点：
 时间复杂度o(1)。 满足“=”，“IN”条件查询。 不支持范围查询，比如between关键字。 不支持order by关键字排序。   3. redis数据模型 我们在描述一种存储类型的中间件时，无论它是缓存类的存储，亦或是传统写入磁盘的关系性数据库存储，都存在它们各自最基础也是最核心的数据存储模型，这里我个人习惯把它叫做数据模型，基于数据模型才能实现上层复杂的结构存储。
redis的数据模型，可以把它看成字典，一种基于key-value存储的数据结构，底层由数组实现的基于hashtable的拉链法存储。
以下是从redis源码中提取的四种以此从外到内的核心数据模型，其中redisDb为最外层，抽丝剥茧之后，不难发现真正的数据存储于底层的dictEntry：
typedef struct redisDb { dict *dict; /* The keyspace for this DB */ dict *expires; /* Timeout of keys with a timeout set */ dict *blocking_keys; /* Keys with clients waiting for data (BLPOP)*/ dict *ready_keys; /* Blocked keys that received a PUSH */ dict *watched_keys; /* WATCHED keys for MULTI/EXEC CAS */ int id; /* Database ID */ long long avg_ttl; /* Average TTL, just for stats */ list *defrag_later; /* List of key names to attempt to defrag one by one, gradually."/>



    <meta property="og:title" content="Redis存储原理剖析&lt;一&gt;：存储模型和基础命令解析" />
<meta property="og:description" content="1. 前言  2022年，是充满挑战性的一年。
这一年，我选择离开了自己熟悉的信息化领域，把精力投向了互联网金融。
在22年的后半程，鉴于平台和团队所带来的效应，个人也在高频交易业务领域吸收了足够多的知识。过程中，认知的颠覆和自我的怀疑常常是共存。
所幸这些经历最后都能够作为养分，支撑我一步步走到当下。
这个系列的文章，初稿实际上在22年的年底就已经完成。但碍于平日里事务繁忙兼琐事繁多，使得日子一再蹉跎，一直推迟到23年过半，才开始尝试去重新梳理其中的些许细节，并准备将它发表在博客里。
初稿原本诞生于22年在高频交易系统的技术选型、架构搭建和研发过程中。当时和团队里优秀的工程师们对redis尝试不断地深入探索，试图吸收其在架构设计方面的优点，并思考对于交易业务领域可以如何进行二次开发以达到发挥极致性能的目的，从而形成了这份初稿。当然，由于保密机制，文档中原先存在的定制化方案和敏感信息已去除，但对redis架构有兴趣的朋友，仍然可以通过这个系列洞悉redis在设计方面的优点。
过程中难免会因为篇幅原因删除细枝末节的代码，这也是为更好的去掌握主流程，让整个文档脉络更清晰而做的取舍。若对内容有异议，可通过邮箱联系我。
 huangzh 2023.08.25    阅读本文档存在一些门槛，不建议新手直接阅读，建议大家先掌握以下必要的技能：  良好的c语言基础。 掌握多路复用编程网络模型。 对操作系统中io的认知。 学习并调试过其他常用中间件代码的经验。 耐心。   redis的存储模型，是典型的hash存储。即一个key对应一个或多个值，这在redis支持的数据类型有着明确的体现，redis一共支持五种类型的数据结构存储：
 string hash（又称为set） list zset zlist  从广义上来看，这五种类型数据的存储都可以用key-value形式去实现，无非是value所对应的值的形式有所不同。
 2. hash存储引擎 提到redis，不得不先提及hash存储引擎的概念，一个典型的hash存储引擎原理如下图所示：
这种基于hash的存储方式，与传统关系性数据库有着非常大的区别。
在内存中通过一定的hash算法均匀的散列key值，使不同的key均匀的散落在hashtable的不同栏位。
由于相同的key可能对应不同的value，因此hashtable每个栏位实际上采用挂载链表的形式存储每一个value节点。
每个value节点中，包含三个最重要的元素：
 position：value的起始位置 size：value对应的长度 fileid：value存储的文件标识符  当然，节点中当然可以包含其他额外的值，不同软件有着自己的额外添加的元素。
但是，不约而外的，通过这三个必要的元素，可以找到key对应的value究竟存储于哪个文件，以及value在该文件中对应的起始位置和长度。
通过这种方式，实际上可以很方便的查找key-value元素。同时，这种方式将hashtable中每个栏位的写入由随机写（hash值随机）转变为顺序写（每个栏位的数据只需要顺序往该栏位对应的文件中添加即可，通过节点链表顺序连接），大大提高了写入的效率。
同时，使用hash存储引擎还存在以下特点：
 时间复杂度o(1)。 满足“=”，“IN”条件查询。 不支持范围查询，比如between关键字。 不支持order by关键字排序。   3. redis数据模型 我们在描述一种存储类型的中间件时，无论它是缓存类的存储，亦或是传统写入磁盘的关系性数据库存储，都存在它们各自最基础也是最核心的数据存储模型，这里我个人习惯把它叫做数据模型，基于数据模型才能实现上层复杂的结构存储。
redis的数据模型，可以把它看成字典，一种基于key-value存储的数据结构，底层由数组实现的基于hashtable的拉链法存储。
以下是从redis源码中提取的四种以此从外到内的核心数据模型，其中redisDb为最外层，抽丝剥茧之后，不难发现真正的数据存储于底层的dictEntry：
typedef struct redisDb { dict *dict; /* The keyspace for this DB */ dict *expires; /* Timeout of keys with a timeout set */ dict *blocking_keys; /* Keys with clients waiting for data (BLPOP)*/ dict *ready_keys; /* Blocked keys that received a PUSH */ dict *watched_keys; /* WATCHED keys for MULTI/EXEC CAS */ int id; /* Database ID */ long long avg_ttl; /* Average TTL, just for stats */ list *defrag_later; /* List of key names to attempt to defrag one by one, gradually." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://Huang-zh.github.io/posts/redis1/" /><meta property="og:image" content="https://Huang-zh.github.io"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-25T22:10:44+08:00" />
<meta property="article:modified_time" content="2023-08-25T22:10:44+08:00" /><meta property="og:site_name" content="此间的少年" />
<meta property="og:see_also" content="https://Huang-zh.github.io/posts/redis3/" /><meta property="og:see_also" content="https://Huang-zh.github.io/posts/redis2/" />





    <meta property="article:section" content="redis原理" />



    <meta property="article:published_time" content="2023-08-25 22:10:44 &#43;0800 CST" />











    </head>

    
        <body>
    
    
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text ">
                huan.g</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="/posts/">文章</a></li><li><a href="/categories/">分类</a></li><li><a href="/about/">关于我</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            
        </span>
    </span>
</header>



            <div class="content">
                
  <main class="post">

    <div class="post-info">
      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock">
          <circle cx="12" cy="12" r="10"></circle>
          <polyline points="12 6 12 12 16 14"></polyline>
        </svg>
        6 minutes

        
      </p>
    </div>

    <article>
      <h1 class="post-title">
        <a href="https://Huang-zh.github.io/posts/redis1/">Redis存储原理剖析&lt;一&gt;：存储模型和基础命令解析</a>
      </h1>

      

      

      

      <div class="post-content">
        <h3 id="1-前言">1. 前言</h3>
<blockquote>
<p>2022年，是充满挑战性的一年。</p>
<p>这一年，我选择离开了自己熟悉的信息化领域，把精力投向了互联网金融。</p>
<p>在22年的后半程，鉴于平台和团队所带来的效应，个人也在高频交易业务领域吸收了足够多的知识。过程中，认知的颠覆和自我的怀疑常常是共存。</p>
<p>所幸这些经历最后都能够作为养分，支撑我一步步走到当下。</p>
<p>这个系列的文章，初稿实际上在22年的年底就已经完成。但碍于平日里事务繁忙兼琐事繁多，使得日子一再蹉跎，一直推迟到23年过半，才开始尝试去重新梳理其中的些许细节，并准备将它发表在博客里。</p>
<p>初稿原本诞生于22年在高频交易系统的技术选型、架构搭建和研发过程中。当时和团队里优秀的工程师们对redis尝试不断地深入探索，试图吸收其在架构设计方面的优点，并思考对于交易业务领域可以如何进行二次开发以达到发挥极致性能的目的，从而形成了这份初稿。当然，由于保密机制，文档中原先存在的定制化方案和敏感信息已去除，但对redis架构有兴趣的朋友，仍然可以通过这个系列洞悉redis在设计方面的优点。</p>
<p>过程中难免会因为篇幅原因删除细枝末节的代码，这也是为更好的去掌握主流程，让整个文档脉络更清晰而做的取舍。若对内容有异议，可通过邮箱联系我。</p>
<pre><code>                                        huangzh
                                        2023.08.25
</code></pre>
</blockquote>
<hr>
<h4 id="阅读本文档存在一些门槛不建议新手直接阅读建议大家先掌握以下必要的技能">阅读本文档存在一些门槛，不建议新手直接阅读，建议大家先掌握以下必要的技能：</h4>
<ul>
<li>良好的c语言基础。</li>
<li>掌握多路复用编程网络模型。</li>
<li>对操作系统中io的认知。</li>
<li>学习并调试过其他常用中间件代码的经验。</li>
<li>耐心。</li>
</ul>
<hr>
<p>redis的存储模型，是典型的hash存储。即一个key对应一个或多个值，这在redis支持的数据类型有着明确的体现，redis一共支持五种类型的数据结构存储：</p>
<ul>
<li>string</li>
<li>hash（又称为set）</li>
<li>list</li>
<li>zset</li>
<li>zlist</li>
</ul>
<p>从广义上来看，这五种类型数据的存储都可以用key-value形式去实现，无非是value所对应的值的形式有所不同。</p>
<hr>
<h3 id="2-hash存储引擎">2. hash存储引擎</h3>
<p>提到redis，不得不先提及hash存储引擎的概念，一个典型的hash存储引擎原理如下图所示：</p>
<p><img src="https://qiniu.lemonhuang.com/hash.png" alt="hash存储示意"></p>
<p>这种基于hash的存储方式，与传统关系性数据库有着非常大的区别。</p>
<p>在内存中通过一定的hash算法均匀的散列key值，使不同的key均匀的散落在hashtable的不同栏位。</p>
<p>由于相同的key可能对应不同的value，因此hashtable每个栏位实际上采用挂载链表的形式存储每一个value节点。</p>
<p>每个value节点中，包含三个最重要的元素：</p>
<ul>
<li>position：value的起始位置</li>
<li>size：value对应的长度</li>
<li>fileid：value存储的文件标识符</li>
</ul>
<p>当然，节点中当然可以包含其他额外的值，不同软件有着自己的额外添加的元素。</p>
<p>但是，不约而外的，通过这三个必要的元素，可以找到key对应的value究竟存储于哪个文件，以及value在该文件中对应的起始位置和长度。</p>
<p>通过这种方式，实际上可以很方便的查找key-value元素。同时，这种方式将hashtable中每个栏位的写入由随机写（hash值随机）转变为顺序写（每个栏位的数据只需要顺序往该栏位对应的文件中添加即可，通过节点链表顺序连接），大大提高了写入的效率。</p>
<p>同时，使用hash存储引擎还存在以下特点：</p>
<ul>
<li>时间复杂度o(1)。</li>
<li>满足“=”，“IN”条件查询。</li>
<li>不支持范围查询，比如between关键字。</li>
<li>不支持order by关键字排序。</li>
</ul>
<hr>
<h3 id="3-redis数据模型">3. redis数据模型</h3>
<p>我们在描述一种存储类型的中间件时，无论它是缓存类的存储，亦或是传统写入磁盘的关系性数据库存储，都存在它们各自最基础也是最核心的数据存储模型，这里我个人习惯把它叫做数据模型，基于数据模型才能实现上层复杂的结构存储。</p>
<p>redis的数据模型，可以把它看成字典，一种基于key-value存储的数据结构，底层由数组实现的基于hashtable的拉链法存储。</p>
<p>以下是从redis源码中提取的四种以此从外到内的核心数据模型，其中redisDb为最外层，抽丝剥茧之后，不难发现真正的数据存储于底层的dictEntry：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> redisDb {
    dict <span style="color:#f92672">*</span>dict;                 <span style="color:#75715e">/* The keyspace for this DB */</span>
    dict <span style="color:#f92672">*</span>expires;              <span style="color:#75715e">/* Timeout of keys with a timeout set */</span>
    dict <span style="color:#f92672">*</span>blocking_keys;        <span style="color:#75715e">/* Keys with clients waiting for data (BLPOP)*/</span>
    dict <span style="color:#f92672">*</span>ready_keys;           <span style="color:#75715e">/* Blocked keys that received a PUSH */</span>
    dict <span style="color:#f92672">*</span>watched_keys;         <span style="color:#75715e">/* WATCHED keys for MULTI/EXEC CAS */</span>
    <span style="color:#66d9ef">int</span> id;                     <span style="color:#75715e">/* Database ID */</span>
    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> avg_ttl;          <span style="color:#75715e">/* Average TTL, just for stats */</span>
    list <span style="color:#f92672">*</span>defrag_later;         <span style="color:#75715e">/* List of key names to attempt to defrag one by one, gradually. */</span>
} redisDb;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> dict {
    dictType <span style="color:#f92672">*</span>type;
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>privdata;
    dictht ht[<span style="color:#ae81ff">2</span>];
    <span style="color:#66d9ef">long</span> rehashidx; <span style="color:#75715e">/* rehashing not in progress if rehashidx == -1 */</span>
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> iterators; <span style="color:#75715e">/* number of iterators currently running */</span>
} dict;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> dictht {
    dictEntry <span style="color:#f92672">**</span>table;
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size;
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> sizemask;
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> used;
} dictht;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> dictEntry {
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key;
    <span style="color:#66d9ef">union</span> {
        <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>val;
        <span style="color:#66d9ef">uint64_t</span> u64;
        <span style="color:#66d9ef">int64_t</span> s64;
        <span style="color:#66d9ef">double</span> d;
    } v;
    <span style="color:#66d9ef">struct</span> dictEntry <span style="color:#f92672">*</span>next;
} dictEntry;
</code></pre></div><p>dictEntry是最基本的存储单元，包含了一组key-value元素，key即存储对应的key值，v所对应的union结构存储具体类型对应的value。还有一个next指针指向下一个存储单元，这样就可以构成一个链表。</p>
<p>dictht（全称dicthashtable）包含多条由dictEntry构成的链表，table作为二级指针，表示一组dictEntry，其中每一个dictEntry存储的值是指向具体存储了某个数据的dictEntry的指针，size标识有几条链表存在，used表示所有链表的节点总数。</p>
<p>dict再封装了两个dictht，一个用于存储真实的key-value数据（datatable），一个用于渐进式hash时临时存放原有的数据，我们的redis客户端指令每次对key的查找请求都是去datatable获取数据。</p>
<p>redisDb封装了dict，此外还有带有expire key的字典，即expires，可以理解为expires内部，用hash存储的方式存储了key对应的过期时间戳。</p>
<hr>
<h3 id="4-命令代码执行过程分析">4. 命令代码执行过程分析</h3>
<p>我们从两个最基本的redis命令案例分析源代码，实际上，这个过程不可能面面俱到，但是只要掌握大体的流程，就可以逐步洞悉内部的精髓。</p>
<h4 id="41-expire-key-expire">4.1 expire key expire</h4>
<p>来看一个最基本的命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">expire testKey 60
</code></pre></div><p>这个命令表示对值为testKey的key，设置60毫秒的过期时间。来看redis代码中对于该命令的处理：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#960050;background-color:#1e0010">ç</span>(client <span style="color:#f92672">*</span>c, redisDb <span style="color:#f92672">*</span>db, robj <span style="color:#f92672">*</span>key, <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> when) {
    dictEntry <span style="color:#f92672">*</span>kde, <span style="color:#f92672">*</span>de;

    <span style="color:#75715e">// 1.先从redisDb中的dict中获取存储了key-value的dictEntry，由kde指针指向该dictEntry的地址
</span><span style="color:#75715e"></span>    kde <span style="color:#f92672">=</span> dictFind(db<span style="color:#f92672">-&gt;</span>dict,key<span style="color:#f92672">-&gt;</span>ptr);
    serverAssertWithInfo(NULL,key,kde <span style="color:#f92672">!=</span> NULL);
  	<span style="color:#75715e">// 2.从redisDb中的expire字典中寻找存储了具体过期时间戳的dictEntry，由de指针指向该dictEntry的地址
</span><span style="color:#75715e"></span>    de <span style="color:#f92672">=</span> dictAddOrFind(db<span style="color:#f92672">-&gt;</span>expires,dictGetKey(kde));
  	<span style="color:#75715e">// 3.更新de所指向的dictEntry中的过期时间
</span><span style="color:#75715e"></span>    dictSetSignedIntegerVal(de,when);
		<span style="color:#75715e">// 4.触发集群间的同步，保证数据一致性
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> writable_slave <span style="color:#f92672">=</span> server.masterhost <span style="color:#f92672">&amp;&amp;</span> server.repl_slave_ro <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">&amp;&amp;</span> writable_slave <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>(c<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> CLIENT_MASTER))
        rememberSlaveKeyWithExpire(db,key);
}
</code></pre></div><p>这里为什么要先从具体存储数据的字典中先查找一遍？个人认为是为了保证数据必须真实存储在字典中，因为redis的过期机制（惰性/LFU/LRU）往往需要cpu花费一些时间片去调度，所以在设计上需要尽可能严格的保证资源的不必要浪费。</p>
<p>dictFind是最基础的查询函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">dictEntry <span style="color:#f92672">*</span><span style="color:#a6e22e">dictFind</span>(dict <span style="color:#f92672">*</span>d, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key)
{
    dictEntry <span style="color:#f92672">*</span>he;
    <span style="color:#66d9ef">uint64_t</span> h, idx, table;
		<span style="color:#75715e">// 1.如果两个dictht的used均为0，说明当前既没有数据存储，也没有发生扩容导致的rehash，直接返回NUll。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].used <span style="color:#f92672">+</span> d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">1</span>].used <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> NULL; 
  	<span style="color:#75715e">// 2.如果当前正在发生扩容，则当前线程帮助推进rehash的过程
</span><span style="color:#75715e"></span>  	<span style="color:#75715e">//   这样做的目的，是将rehash的压力分担到各个操作中去（修改/删除/查询）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (dictIsRehashing(d)) _dictRehashStep(d);
  	<span style="color:#75715e">// 3.得到key的hash值
</span><span style="color:#75715e"></span>    h <span style="color:#f92672">=</span> dictHashKey(d, key);
  	<span style="color:#75715e">// 4.hash值模上hashtable的使用栏位数量，得到一个由dictEntry构成的链表
</span><span style="color:#75715e"></span>  	<span style="color:#75715e">//   依次遍历每一个dictEntry，比较key的值，得到最终的entry
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (table <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; table <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>; table<span style="color:#f92672">++</span>) {
        idx <span style="color:#f92672">=</span> h <span style="color:#f92672">&amp;</span> d<span style="color:#f92672">-&gt;</span>ht[table].sizemask;
        he <span style="color:#f92672">=</span> d<span style="color:#f92672">-&gt;</span>ht[table].table[idx];
        <span style="color:#66d9ef">while</span>(he) {
            <span style="color:#66d9ef">if</span> (key<span style="color:#f92672">==</span>he<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">||</span> dictCompareKeys(d, key, he<span style="color:#f92672">-&gt;</span>key))
                <span style="color:#66d9ef">return</span> he;
            he <span style="color:#f92672">=</span> he<span style="color:#f92672">-&gt;</span>next;
        }
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dictIsRehashing(d)) <span style="color:#66d9ef">return</span> NULL;
    }
    <span style="color:#66d9ef">return</span> NULL;
}
</code></pre></div><p>接下来看看dictAddOrFind，这个方法对key进行查找，如果不存在会新增，否则得到原本就存在的dictEntry。是否符合我们expire命令的逻辑？原先testKey不存在expireTime，我们通过命令设置expireTime的过程就是在expire字典中新增一个dictEntry，然后设置它的value为expireTime对应的时间戳：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">dictEntry <span style="color:#f92672">*</span><span style="color:#a6e22e">dictAddOrFind</span>(dict <span style="color:#f92672">*</span>d, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key) {
    dictEntry <span style="color:#f92672">*</span>entry, <span style="color:#f92672">*</span>existing;
    entry <span style="color:#f92672">=</span> dictAddRaw(d,key,<span style="color:#f92672">&amp;</span>existing);
  	<span style="color:#75715e">//如果entry指针的值存在，说明entry指针指向的dictEntry是通过dictAddRaw新增的，否则返回原本存在的existing地址。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> entry <span style="color:#f92672">?</span> entry : existing;
}

dictEntry <span style="color:#f92672">*</span><span style="color:#a6e22e">dictAddRaw</span>(dict <span style="color:#f92672">*</span>d, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key, dictEntry <span style="color:#f92672">**</span>existing)
{
    <span style="color:#66d9ef">long</span> index;
    dictEntry <span style="color:#f92672">*</span>entry;
    dictht <span style="color:#f92672">*</span>ht;
		<span style="color:#75715e">// 1.如果当前正在发生扩容，则当前线程帮助推进rehash的过程
</span><span style="color:#75715e"></span>  	<span style="color:#75715e">//   这样做的目的，是将rehash的压力分担到各个操作中去（修改/删除/查询）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (dictIsRehashing(d)) _dictRehashStep(d);

    <span style="color:#75715e">// 2.如果计算出index为-1，代表原先存在，返回null
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ((index <span style="color:#f92672">=</span> _dictKeyIndex(d, key, dictHashKey(d,key), existing)) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
        <span style="color:#66d9ef">return</span> NULL;

    <span style="color:#75715e">// 3.1 原先不存在，判断是否处于rehash状态，如果是就将数据存储于第二个hashtable，否则存储于第一个hashtable
</span><span style="color:#75715e"></span>  	ht <span style="color:#f92672">=</span> dictIsRehashing(d) <span style="color:#f92672">?</span> <span style="color:#f92672">&amp;</span>d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">:</span> <span style="color:#f92672">&amp;</span>d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>];
    <span style="color:#75715e">// 3.2 分配需要的内存，将新的dictEntry插入链表的头部
</span><span style="color:#75715e"></span>    entry <span style="color:#f92672">=</span> zmalloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>entry));
    entry<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> ht<span style="color:#f92672">-&gt;</span>table[index];
    ht<span style="color:#f92672">-&gt;</span>table[index] <span style="color:#f92672">=</span> entry;
    ht<span style="color:#f92672">-&gt;</span>used<span style="color:#f92672">++</span>;

    <span style="color:#75715e">// 4.为新的dictEntry设置key值
</span><span style="color:#75715e"></span>    dictSetKey(d, entry, key);
    <span style="color:#66d9ef">return</span> entry;
}
</code></pre></div><p>如果觉得不够清晰，可以看一下dictFind的调用时序图：</p>

<script async type="application/javascript" src="https://cdn.jsdelivr.net/npm/mermaid@9.1.1/dist/mermaid.min.js">
    var config = {
      startOnLoad:true,
      theme:'neutral',
      align:'left'
    };
    mermaid.initialize(config);
  </script>
  
  <div class="mermaid">
    
   sequenceDiagram
　　participant dictAddOrFind
　　participant dictAddRaw
　　dictAddOrFind->>dictAddRaw:invoke
　　
　　Note OVER		dictAddRaw: 判断是否触发_dictRehashStep推进rehash
　　Note OVER		dictAddRaw: 计算index，判断是否已存在entry，存在直接返回NULL
　　Note OVER		dictAddRaw: 判断是否处于rehash过程，决定存储于哪个hashtable
　　Note OVER		dictAddRaw: 分配内存，构造dictEntry，插入链表头部
　　Note OVER		dictAddRaw: 为新的dictEntry设置key值
　　
　　dictAddRaw-->>dictAddOrFind:return
　　Note OVER		dictAddOrFind: 已存在返回&existing，否则返回dictEntry *entry

  </div>

<hr>
<h4 id="42-set-key-value">4.2 set key value</h4>
<p>再来看一个命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">set name huangzh
</code></pre></div><p>这是最基本的添加数据命令，表示我们可以使用该命令创造一个key为name，value为huangzh的dictEntry。那么，从这个命令进入redis-server端的代码，看看它的执行流程：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setKey</span>(redisDb <span style="color:#f92672">*</span>db, robj <span style="color:#f92672">*</span>key, robj <span style="color:#f92672">*</span>val) {
  	<span style="color:#75715e">// 1.lookupKeyWrite查找字典中是否存在key，内部实际上仍然调用dictFind基础查询函数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (lookupKeyWrite(db,key) <span style="color:#f92672">==</span> NULL) {
      	<span style="color:#75715e">// 2.如果当前key在字典中不存在，新增
</span><span style="color:#75715e"></span>        dbAdd(db,key,val);
    } <span style="color:#66d9ef">else</span> {
      	<span style="color:#75715e">// 3.如果当前key在字典中存在，覆盖
</span><span style="color:#75715e"></span>        dbOverwrite(db,key,val);
    }
  	<span style="color:#75715e">// 4.value的引用计数+1
</span><span style="color:#75715e"></span>    incrRefCount(val);
  	<span style="color:#75715e">// 5.如果原先db中存在key且配置了expireTime，这一步会直接移除存储old key过期时间的dictEntry
</span><span style="color:#75715e"></span>    removeExpire(db,key);
  	<span style="color:#75715e">// 6.通知watch了该key的客户端
</span><span style="color:#75715e"></span>    signalModifiedKey(db,key);
}
</code></pre></div><p>这里我们看到了新的类型robj，它的全称是redisObject，事实上，在dictEntry中，存储的key和value时的传参都是用它作为载体：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> redisObject {
  	<span style="color:#75715e">// 类型，枚举值，对应了redis支持的所有数据类型
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> type:<span style="color:#ae81ff">4</span>;
  	<span style="color:#75715e">// 编码
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> encoding:<span style="color:#ae81ff">4</span>;
  	<span style="color:#75715e">// 24位存储，用于LRU或是LFU淘汰机制，在后面会专门描述
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> lru:LRU_BITS; 
  	<span style="color:#75715e">// 当前引用数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> refcount;
  	<span style="color:#75715e">// 指向具体值的指针
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr;
} robj;
</code></pre></div><p>回到setKey的主流程，上面说到，如果当前字典不存在key，则调用dbAdd函数进行新增，我们从这里进入内部的实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dbAdd</span>(redisDb <span style="color:#f92672">*</span>db, robj <span style="color:#f92672">*</span>key, robj <span style="color:#f92672">*</span>val) {
  	<span style="color:#75715e">//sds 全称Simple Dynamic Strings，是redis中提供的简易安全的字符串库
</span><span style="color:#75715e"></span>    sds copy <span style="color:#f92672">=</span> sdsdup(key<span style="color:#f92672">-&gt;</span>ptr);
  	<span style="color:#75715e">// 调用字典的新增方法
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> retval <span style="color:#f92672">=</span> dictAdd(db<span style="color:#f92672">-&gt;</span>dict, copy, val);

    serverAssertWithInfo(NULL,key,retval <span style="color:#f92672">==</span> DICT_OK);
    <span style="color:#66d9ef">if</span> (val<span style="color:#f92672">-&gt;</span>type <span style="color:#f92672">==</span> OBJ_LIST <span style="color:#f92672">||</span>
        val<span style="color:#f92672">-&gt;</span>type <span style="color:#f92672">==</span> OBJ_ZSET)
        signalKeyAsReady(db, key);
    <span style="color:#66d9ef">if</span> (server.cluster_enabled) slotToKeyAdd(key);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dictAdd</span>(dict <span style="color:#f92672">*</span>d, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>val)
{		
  	<span style="color:#75715e">//实际新增在这一步，dictAddRaw已经分析过，不做赘述
</span><span style="color:#75715e"></span>    dictEntry <span style="color:#f92672">*</span>entry <span style="color:#f92672">=</span> dictAddRaw(d,key,NULL);

    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>entry) <span style="color:#66d9ef">return</span> DICT_ERR;
  	<span style="color:#75715e">//为新增的dictEntry填充value
</span><span style="color:#75715e"></span>    dictSetVal(d, entry, val);
    <span style="color:#66d9ef">return</span> DICT_OK;
}
</code></pre></div><p>这里出现了一个结构体叫做sds，全称Simple Dynamic Strings，是redis提供的字符串高效操作库，不是分析的重点，具体可参考https://github.com/antirez/sds。</p>
<p>可以看到实际调用dictAddRaw函数进行新增的时候，传入的是sds，而在之前已经分析过，dictAddRaw会对新增的dictEntry进行key的填充，所以我们可以得出，其实sds才是key作为存储的数据载体，那么来看一下构造sds的过程：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">sds <span style="color:#a6e22e">sdsdup</span>(<span style="color:#66d9ef">const</span> sds s) {
    <span style="color:#66d9ef">return</span> sdsnewlen(s, sdslen(s));
}

sds <span style="color:#a6e22e">sdsnewlen</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>init, size_t initlen) {
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>sh;
    sds s;
  	<span style="color:#75715e">// 根据初始字符串决定构造的动态字符串类型
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> type <span style="color:#f92672">=</span> sdsReqType(initlen);
    <span style="color:#75715e">// 空串判断
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (type <span style="color:#f92672">==</span> SDS_TYPE_5 <span style="color:#f92672">&amp;&amp;</span> initlen <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) type <span style="color:#f92672">=</span> SDS_TYPE_8;
    <span style="color:#66d9ef">int</span> hdrlen <span style="color:#f92672">=</span> sdsHdrSize(type);
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>fp;

    assert(hdrlen<span style="color:#f92672">+</span>initlen<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;</span> initlen); 
  	<span style="color:#75715e">//分配需要的内存，sds的结构：header的长度+字符串值的初始长度+末尾的空项长度
</span><span style="color:#75715e"></span>    sh <span style="color:#f92672">=</span> s_malloc(hdrlen<span style="color:#f92672">+</span>initlen<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">if</span> (init<span style="color:#f92672">==</span>SDS_NOINIT)
        init <span style="color:#f92672">=</span> NULL;
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>init)
        memset(sh, <span style="color:#ae81ff">0</span>, hdrlen<span style="color:#f92672">+</span>initlen<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">if</span> (sh <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> NULL;
    s <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)sh<span style="color:#f92672">+</span>hdrlen;
  	<span style="color:#75715e">//fp是返回用于读取的实际指针，指向header末尾
</span><span style="color:#75715e"></span>    fp <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)s)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
  	<span style="color:#75715e">//根据不同的类型，构造实际的动态字符串
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">switch</span>(type) {
        <span style="color:#66d9ef">case</span> SDS_TYPE_5: {
            <span style="color:#f92672">*</span>fp <span style="color:#f92672">=</span> type <span style="color:#f92672">|</span> (initlen <span style="color:#f92672">&lt;&lt;</span> SDS_TYPE_BITS);
            <span style="color:#66d9ef">break</span>;
        }
        <span style="color:#66d9ef">case</span> SDS_TYPE_8: {
            SDS_HDR_VAR(<span style="color:#ae81ff">8</span>,s);
            sh<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">=</span> initlen;
            sh<span style="color:#f92672">-&gt;</span>alloc <span style="color:#f92672">=</span> initlen;
            <span style="color:#f92672">*</span>fp <span style="color:#f92672">=</span> type;
            <span style="color:#66d9ef">break</span>;
        }
        <span style="color:#66d9ef">case</span> SDS_TYPE_16: {
            SDS_HDR_VAR(<span style="color:#ae81ff">16</span>,s);
            sh<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">=</span> initlen;
            sh<span style="color:#f92672">-&gt;</span>alloc <span style="color:#f92672">=</span> initlen;
            <span style="color:#f92672">*</span>fp <span style="color:#f92672">=</span> type;
            <span style="color:#66d9ef">break</span>;
        }
        <span style="color:#66d9ef">case</span> SDS_TYPE_32: {
            SDS_HDR_VAR(<span style="color:#ae81ff">32</span>,s);
            sh<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">=</span> initlen;
            sh<span style="color:#f92672">-&gt;</span>alloc <span style="color:#f92672">=</span> initlen;
            <span style="color:#f92672">*</span>fp <span style="color:#f92672">=</span> type;
            <span style="color:#66d9ef">break</span>;
        }
        <span style="color:#66d9ef">case</span> SDS_TYPE_64: {
            SDS_HDR_VAR(<span style="color:#ae81ff">64</span>,s);
            sh<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">=</span> initlen;
            sh<span style="color:#f92672">-&gt;</span>alloc <span style="color:#f92672">=</span> initlen;
            <span style="color:#f92672">*</span>fp <span style="color:#f92672">=</span> type;
            <span style="color:#66d9ef">break</span>;
        }
    }
    <span style="color:#66d9ef">if</span> (initlen <span style="color:#f92672">&amp;&amp;</span> init)
      	<span style="color:#75715e">//拷贝字符串的值到新构造的动态字符串
</span><span style="color:#75715e"></span>        memcpy(s, init, initlen);
  	<span style="color:#75715e">//末尾空项补齐
</span><span style="color:#75715e"></span>    s[initlen] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;
    <span style="color:#66d9ef">return</span> s;
}
</code></pre></div><p>最后来看一下不同type对应的动态字符串内部结构，可以看到它们都包含了表示长度的len和存储实际字符的数组buf，sdshdr5比较特殊，因为定位其为空串，所以不需要记录长度：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__attribute__</span> ((__packed__)) sdshdr5 {
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> flags; 
    <span style="color:#66d9ef">char</span> buf[];
};
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__attribute__</span> ((__packed__)) sdshdr8 {
    <span style="color:#66d9ef">uint8_t</span> len; 
    <span style="color:#66d9ef">uint8_t</span> alloc; 
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> flags; 
    <span style="color:#66d9ef">char</span> buf[];
};
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__attribute__</span> ((__packed__)) sdshdr16 {
    <span style="color:#66d9ef">uint16_t</span> len; 
    <span style="color:#66d9ef">uint16_t</span> alloc; 
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> flags; 
    <span style="color:#66d9ef">char</span> buf[];
};
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__attribute__</span> ((__packed__)) sdshdr32 {
    <span style="color:#66d9ef">uint32_t</span> len; 
    <span style="color:#66d9ef">uint32_t</span> alloc; 
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> flags;
    <span style="color:#66d9ef">char</span> buf[];
};
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__attribute__</span> ((__packed__)) sdshdr64 {
    <span style="color:#66d9ef">uint64_t</span> len; 
    <span style="color:#66d9ef">uint64_t</span> alloc; 
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> flags; 
    <span style="color:#66d9ef">char</span> buf[];
};
</code></pre></div><p>接着再回到setKey的主流程，看看removeExpire的内部逻辑：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">removeExpire</span>(redisDb <span style="color:#f92672">*</span>db, robj <span style="color:#f92672">*</span>key) {
    serverAssertWithInfo(NULL,key,dictFind(db<span style="color:#f92672">-&gt;</span>dict,key<span style="color:#f92672">-&gt;</span>ptr) <span style="color:#f92672">!=</span> NULL);
  	<span style="color:#75715e">//从db中的exipre字典删除key对应的dictEntry
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> dictDelete(db<span style="color:#f92672">-&gt;</span>expires,key<span style="color:#f92672">-&gt;</span>ptr) <span style="color:#f92672">==</span> DICT_OK;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dictDelete</span>(dict <span style="color:#f92672">*</span>ht, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key) {
    <span style="color:#66d9ef">return</span> dictGenericDelete(ht,key,<span style="color:#ae81ff">0</span>) <span style="color:#f92672">?</span> DICT_OK : DICT_ERR;
}

<span style="color:#66d9ef">static</span> dictEntry <span style="color:#f92672">*</span><span style="color:#a6e22e">dictGenericDelete</span>(dict <span style="color:#f92672">*</span>d, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key, <span style="color:#66d9ef">int</span> nofree) {
    <span style="color:#66d9ef">uint64_t</span> h, idx;
    dictEntry <span style="color:#f92672">*</span>he, <span style="color:#f92672">*</span>prevHe;
    <span style="color:#66d9ef">int</span> table;
		<span style="color:#75715e">//当前没有数据存储，直接返回NULL
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].used <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">1</span>].used <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> NULL;
		<span style="color:#75715e">//如果当前正在rehash，则触发推进rehash的过程
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (dictIsRehashing(d)) _dictRehashStep(d);
  	<span style="color:#75715e">//计算hash值
</span><span style="color:#75715e"></span>    h <span style="color:#f92672">=</span> dictHashKey(d, key);
		
  	<span style="color:#75715e">//遍历两个hashtable，找到链表中符合key值的dictEntry
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (table <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; table <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>; table<span style="color:#f92672">++</span>) {
        idx <span style="color:#f92672">=</span> h <span style="color:#f92672">&amp;</span> d<span style="color:#f92672">-&gt;</span>ht[table].sizemask;
        he <span style="color:#f92672">=</span> d<span style="color:#f92672">-&gt;</span>ht[table].table[idx];
        prevHe <span style="color:#f92672">=</span> NULL;
        <span style="color:#66d9ef">while</span>(he) {
            <span style="color:#66d9ef">if</span> (key<span style="color:#f92672">==</span>he<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">||</span> dictCompareKeys(d, key, he<span style="color:#f92672">-&gt;</span>key)) {
                <span style="color:#66d9ef">if</span> (prevHe)
                  	<span style="color:#75715e">//当前节点的前继节点的下一个节点指针直接指向当前节点的后继节点
</span><span style="color:#75715e"></span>                    prevHe<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> he<span style="color:#f92672">-&gt;</span>next;
                <span style="color:#66d9ef">else</span>
                  	<span style="color:#75715e">//如果是头节点，则头节点指针改为当前节点的后继节点
</span><span style="color:#75715e"></span>                    d<span style="color:#f92672">-&gt;</span>ht[table].table[idx] <span style="color:#f92672">=</span> he<span style="color:#f92672">-&gt;</span>next;
                <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>nofree) {
                  	<span style="color:#75715e">//释放内存
</span><span style="color:#75715e"></span>                    dictFreeKey(d, he);
                    dictFreeVal(d, he);
                    zfree(he);
                }
              	<span style="color:#75715e">//hashtable的节点使用数-1
</span><span style="color:#75715e"></span>                d<span style="color:#f92672">-&gt;</span>ht[table].used<span style="color:#f92672">--</span>;
                <span style="color:#66d9ef">return</span> he;
            }
            prevHe <span style="color:#f92672">=</span> he;
            he <span style="color:#f92672">=</span> he<span style="color:#f92672">-&gt;</span>next;
        }
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dictIsRehashing(d)) <span style="color:#66d9ef">break</span>;
    }
  	<span style="color:#75715e">//如果没命中key，则返回NULL
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> NULL; 
}
</code></pre></div><p>那么，来画一个简单的setKey函数执行add key命令时的时序图，省略集群同步和监听通知等步骤后如下：

<script async type="application/javascript" src="https://cdn.jsdelivr.net/npm/mermaid@9.1.1/dist/mermaid.min.js">
    var config = {
      startOnLoad:true,
      theme:'neutral',
      align:'left'
    };
    mermaid.initialize(config);
  </script>
  
  <div class="mermaid">
    
  sequenceDiagram
　　participant setKey
　　participant lookupKeyWrite
　　participant dictFind
　	 participant dbAdd
　	 participant dictAdd
　　setKey->>lookupKeyWrite:invoke
　　
　　lookupKeyWrite->>dictFind:invoke
　　dictFind-->>lookupKeyWrite:return
　　
　　lookupKeyWrite-->>setKey:return
　　Note OVER setKey: 判断dictEntry是否存在，不存在就调用dbAdd新增
		setKey->>dbAdd:invoke
		Note OVER	dbAdd: 创建sds，装载redisObject中的ptr值
		dbAdd->>dictAdd:invoke
		Note OVER dictAdd: 调用dictAddRaw，创建dictEntry，存入hashtable并填充key值
		Note OVER dictAdd: 调用dictSetVal填充value
		dictAdd-->>dbAdd:return
		dbAdd-->>setKey:return
		Note OVER setKey: 调用incrRefCount使value引用计数+1
		Note OVER setKey: 调用removeExpire重置expire过期时间

  </div>
</p>
<p>比起一层层深入的跟踪源码，这种时序图能更直观的反应代码执行时的主体流程，也更考验对代码整体逻辑的总结归纳能力。</p>
<p>至此，通过两个简单案例的分析，由浅入深，可以洞悉redis在存储数据时其字典数据结构的全貌：</p>
<p><img src="https://qiniu.lemonhuang.com/Untitled%20Diagram.drawio%20%281%29.png" alt="redis存储数据模型"></p>
<hr>
<h3 id="5-key对内存的影响">5. Key对内存的影响</h3>
<p>实际上，在redis中，一个key往往需要存储在两个hashtable中，一个是存储data的ht，而另一份则是存储了过期时间戳的ht。也就意味着，如果为一个key设置了expireTime，那么在redis会存在两份key，这使得在一些极端情况不得不考虑key的大小对内存占用的影响。</p>
<p>通过上面的分析，已经知道真正存储key的是sds结构体，但是在转化sds之前，需要先经过dictEntry和redisObject的过渡，也就意味着创建dictEntry和redisObject的内存全部都要计入key的存储范围。</p>
<p>我们以64位编译器为例子，先看redisObject的结构：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> redisObject {
    <span style="color:#66d9ef">unsigned</span> type:<span style="color:#ae81ff">4</span>;
    <span style="color:#66d9ef">unsigned</span> encoding:<span style="color:#ae81ff">4</span>;
    <span style="color:#66d9ef">unsigned</span> lru:LRU_BITS; 
    <span style="color:#66d9ef">int</span> refcount;
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr;
} robj;
</code></pre></div><p>64位编译器的void指针占用8个字节，int类型占用4个字节。LRU_BITS为24，即24位3个字节。type4位，encoding4位，合计一个字节。所以构成一个redisObject需要16个字节的容量。</p>
<p>再看dictEntry：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> dictEntry {
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key;
    <span style="color:#66d9ef">union</span> {
        <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>val;
        <span style="color:#66d9ef">uint64_t</span> u64;
        <span style="color:#66d9ef">int64_t</span> s64;
        <span style="color:#66d9ef">double</span> d;
    } v;
    <span style="color:#66d9ef">struct</span> dictEntry <span style="color:#f92672">*</span>next;
} dictEntry;
</code></pre></div><p>针对64位编译器void指针还是8个字节，union里所有的类型均占用8个字节，next为结构体指针，因此在64位编译器中也占用8个字节，因此构成一个dictEntry需要24个字节的容量。</p>
<p>最后我们看sds，这里我们使用上面值为testKey作为例子，首先testKey字符串的长度为七个字节，会被分配到的sds类型结构如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__attribute__</span> ((__packed__)) sdshdr8 {
    <span style="color:#66d9ef">uint8_t</span> len; 
    <span style="color:#66d9ef">uint8_t</span> alloc; 
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> flags; 
    <span style="color:#66d9ef">char</span> buf[];
};
</code></pre></div><p>需要的字节数为1+1+1+7 = 10个字节。</p>
<p>那么，对于调用命令添加一个testKey，所需要的字节总数为16+24+10 = 50。</p>
<p>在设计key的过程中，应当避免key过长。</p>
<p>同时，redis针对这种由于key的字节长度引起的存储容量问题，有着自己的key删除策略和过期淘汰机制。</p>
<p>key删除策略和过期淘汰机制将会在后续的章节中展开分析。</p>

      </div>
    </article>

    <hr />

    <div class="post-info">
      
    <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg>

        <span class="tag"><a href="https://Huang-zh.github.io/tags/redis/">redis</a></span>
        
    </p>

      
    <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-folder meta-icon"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>

        <span class="tag"><a href="https://Huang-zh.github.io/categories/redis%E5%8E%9F%E7%90%86/">redis原理</a></span>
        
    </p>


      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14 2 14 8 20 8"></polyline>
          <line x1="16" y1="13" x2="8" y2="13"></line>
          <line x1="16" y1="17" x2="8" y2="17"></line>
          <polyline points="10 9 9 9 8 9"></polyline>
        </svg>
        1135 Words
      </p>

      <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-calendar">
          <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect>
          <line x1="16" y1="2" x2="16" y2="6"></line>
          <line x1="8" y1="2" x2="8" y2="6"></line>
          <line x1="3" y1="10" x2="21" y2="10"></line>
        </svg>
        
          2023-08-25
        

        
      </p>
    </div>

    
    <div class="pagination">
        

        <div class="pagination__buttons">
            
            <span class="button previous">
                <a href="https://Huang-zh.github.io/posts/redis2/">
                    <span class="button__icon">←</span>
                    <span class="button__text">Redis存储原理剖析&lt;二&gt;：key的惰性删除--同步删除策略</span>
                </a>
            </span>
            

            
            <span class="button next">
                <a href="https://Huang-zh.github.io/posts/firstpost/">
                    <span class="button__text">浮生如梦</span>
                    <span class="button__icon">→</span>
                </a>
            </span>
            
        </div>
    </div>


    

    

  </main>

            </div>

            
                <footer class="footer">
    
    
    <div class="footer__inner">
        <div class="footer__content">
            <span><a href="http://beian.miit.gov.cn">浙ICP备19022115号-1</a></span>
        </div>
    </div>
    
</footer>



            
        </div>

        



<script type="text/javascript" src="/bundle.min.644292943ae47eef02fcd64b11757aeb8caeeaebf473a823b62099edccac808e8d82689359f285e5d95994e5ad5ae3b9c1ccc281eb1828e67d0ba6630f95b832.js" integrity="sha512-ZEKSlDrkfu8C/NZLEXV664yu6uv0c6gjtiCZ7cysgI6NgmiTWfKF5dlZlOWtWuO5wczCgesYKOZ9C6ZjD5W4Mg=="></script>



    </body>
</html>
