<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on 此间的少年</title>
        <link>https://Huang-zh.github.io/posts/</link>
        <description>Recent content in Posts on 此间的少年</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Sat, 09 Sep 2023 21:02:25 +0800</lastBuildDate>
        <atom:link href="https://Huang-zh.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>LeetCode算法手记：792.匹配子序列的单词数</title>
            <link>https://Huang-zh.github.io/posts/leetcode792/</link>
            <pubDate>Sat, 09 Sep 2023 21:02:25 +0800</pubDate>
            
            <guid>https://Huang-zh.github.io/posts/leetcode792/</guid>
            <description>给定字符串 s 和字符串数组 words, 返回 words[i] 中是 s 的子序列的单词个数。 字符串的子序列是从原始字符串中生成的新字符串，可以从中删去一些字符(可以是 none)，而不改变其余字符的相对顺序。 例如， “ace” 是 “abcde” 的子序列。 示例 1： 输入: s = “abcde”, words = [“a”,“bb”,“acd”,“ace”] 输出: 3 解释: 有三个是 s 的子序列的单词: “a”, “acd”, “ace”。 示例 2： 输入: s = “dsahjpjauf”, words = [“ahjpjau”,“ja”,“ahbwzgqnuk”,“tnmlanowax”] 输出: 2 提示： 1 &amp;lt;= s.length &amp;lt;= 5 * 104 1 &amp;lt;= words.length &amp;lt;= 5000 1 &amp;lt;= words[i].length &amp;lt;= 50 words[i]和 s 都只由小写字母组成。 思路 对于字符串s和字符串t，若s为t的子序列，则需要满足以下几点：
 s中的所有字符的相对顺序，必须和这些字符在t中出现的相对顺序保持一致，例如s为ace，t为abcde，则s为t的子序列，此时a、c、e三个字符在两个字符串中出现的相对顺序保持一致，t可以通过删除b和d两个字符来得到s。 若s由一个或多个相同字符组成，那么该字符在s中出现的次数必然小于等于t中该字符出现的次数，例如字符串a、aa、aaa均为字符串aabade的子序列，但aaaa不是字符串aabade的子序列。  那么，维护一个数组，记录下原字符串t中每一个字符t[i]出现的位置i，然后对于要判断子序列的样本s，遍历s的每个字符，判断以下几点：</description>
            <content type="html"><![CDATA[<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">给定字符串 s 和字符串数组 words, 返回 words[i] 中是 s 的子序列的单词个数。

字符串的子序列是从原始字符串中生成的新字符串，可以从中删去一些字符(可以是 none)，而不改变其余字符的相对顺序。

例如， “ace” 是 “abcde” 的子序列。

示例 1：
输入: s = “abcde”, words = [“a”,“bb”,“acd”,“ace”]
输出: 3
解释: 有三个是 s 的子序列的单词: “a”, “acd”, “ace”。

示例 2：
输入: s = “dsahjpjauf”, words = [“ahjpjau”,“ja”,“ahbwzgqnuk”,“tnmlanowax”]
输出: 2

提示：
1 &lt;= s.length &lt;= 5 * 104
1 &lt;= words.length &lt;= 5000
1 &lt;= words[i].length &lt;= 50
words[i]和 s 都只由小写字母组成。
</code></pre></div><h3 id="思路">思路</h3>
<p>对于字符串s和字符串t，若s为t的子序列，则需要满足以下几点：</p>
<ul>
<li>s中的所有字符的相对顺序，必须和这些字符在t中出现的相对顺序保持一致，例如s为ace，t为abcde，则s为t的子序列，此时a、c、e三个字符在两个字符串中出现的相对顺序保持一致，t可以通过删除b和d两个字符来得到s。</li>
<li>若s由一个或多个相同字符组成，那么该字符在s中出现的次数必然小于等于t中该字符出现的次数，例如字符串a、aa、aaa均为字符串aabade的子序列，但aaaa不是字符串aabade的子序列。</li>
</ul>
<p>那么，维护一个数组，记录下原字符串t中每一个字符t[i]出现的位置i，然后对于要判断子序列的样本s，遍历s的每个字符，判断以下几点：</p>
<ul>
<li>如果对于当前字符s[i]，数组中找不到对应的位置记录，则说明s[i]字符在t中不曾出现，不满足子序列要求。</li>
<li>如果能够找到对应的位置记录，则说明s[i]字符在t中有出现，需要判断s[i]字符在t中出现的个数，如果超过t中出现该字符的个数，不满足子序列要求。</li>
<li>如果对于字符串s，上面两点均满足子序列的要求，则说明当前字符串s在[0,i]位置的字符构成的字符串已满足子序列要求，指针向后遍历下一个s[i+1]字符，同时，由于相对顺序保持一致，将j向后移动，s[i+1]将和t[i+1]进行判断。</li>
</ul>
<h3 id="代码实现">代码实现</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"> <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">numMatchingSubseq</span><span style="color:#f92672">(</span>String s<span style="color:#f92672">,</span> String<span style="color:#f92672">[]</span> words<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> numMatchingSubseqByLeftBondBinarySearch<span style="color:#f92672">(</span>s<span style="color:#f92672">,</span> words<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * @Author huang.zh
</span><span style="color:#75715e">     * @Description //二分查找解法，判断子序列个数
</span><span style="color:#75715e">     * @Date 10:21 PM 2023/9/9
</span><span style="color:#75715e">     * @Param [s, words]
</span><span style="color:#75715e">     * @return
</span><span style="color:#75715e">     **/</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">numMatchingSubseqByLeftBondBinarySearch</span><span style="color:#f92672">(</span>String s<span style="color:#f92672">,</span> String<span style="color:#f92672">[]</span> words<span style="color:#f92672">){</span>
        ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;[]</span> arrays <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">[</span>26<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">int</span> sLength <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">();</span>
        <span style="color:#75715e">//对原样本进行预处理，记录s中每一个字符出现的下标位置
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> sLength<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>i<span style="color:#f92672">)</span> <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>arrays<span style="color:#f92672">[</span>index<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                arrays<span style="color:#f92672">[</span>index<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>
            <span style="color:#75715e">//记录当前字符s[i]对应的位置i
</span><span style="color:#75715e"></span>            arrays<span style="color:#f92672">[</span>index<span style="color:#f92672">].</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>i<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>String word <span style="color:#f92672">:</span> words<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>isSubSequence<span style="color:#f92672">(</span>word<span style="color:#f92672">,</span>arrays<span style="color:#f92672">))</span>
                result<span style="color:#f92672">++;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> result<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * @Author huang.zh
</span><span style="color:#75715e">     * @Description 判断s是否为子序列
</span><span style="color:#75715e">     * @Date 10:31 PM 2023/9/9
</span><span style="color:#75715e">     * @Param [s, arrays]
</span><span style="color:#75715e">     * @return
</span><span style="color:#75715e">     **/</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isSubSequence</span><span style="color:#f92672">(</span>String s<span style="color:#f92672">,</span>ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;[]</span> arrays<span style="color:#f92672">){</span>
        <span style="color:#75715e">//定义指针j，在搜寻过程中每找到一个字符就向后移动一位，确保s中每个字符的相对顺序必须和原字符串中一致，才能算作子序列
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">();</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>i<span style="color:#f92672">)</span> <span style="color:#f92672">-</span> <span style="color:#e6db74">&#39;a&#39;</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>arrays<span style="color:#f92672">[</span>index<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                <span style="color:#75715e">//当前字符在原字符串中没出现过，肯定不是子序列
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
            <span style="color:#75715e">//搜寻当前字符在原字符串中第一次出现的位置
</span><span style="color:#75715e"></span>            <span style="color:#75715e">//由于子序列的相对顺序必须和原字符串一致，所以point一定会落在[0,arrays[index].size())内
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> point <span style="color:#f92672">=</span> leftBondBinarySearch<span style="color:#f92672">(</span>arrays<span style="color:#f92672">[</span>index<span style="color:#f92672">],</span> j<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>point <span style="color:#f92672">==</span> arrays<span style="color:#f92672">[</span>index<span style="color:#f92672">].</span><span style="color:#a6e22e">size</span><span style="color:#f92672">())</span>
                <span style="color:#75715e">//防止重复字符超出原字符中同字符的长度上限，比如原字符为aa，s为aaa，显然不符合子序列
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
            <span style="color:#75715e">//当前字符满足条件，将j指针往后移动，用于下一个字符判断
</span><span style="color:#75715e"></span>            j <span style="color:#f92672">=</span> arrays<span style="color:#f92672">[</span>index<span style="color:#f92672">].</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>point<span style="color:#f92672">)+</span>1<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * @Author huang.zh
</span><span style="color:#75715e">     * @Description 找到数组中第一个值为target的元素下标
</span><span style="color:#75715e">     * @Date 10:23 PM 2023/9/9
</span><span style="color:#75715e">     * @Param [list, target]
</span><span style="color:#75715e">     * @return
</span><span style="color:#75715e">     **/</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">leftBondBinarySearch</span><span style="color:#f92672">(</span>ArrayList<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> list<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> target<span style="color:#f92672">){</span>
        <span style="color:#75715e">//注意high的取值，代表在左闭右开区间[low,high)中去搜寻第一个符合的元素
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> low <span style="color:#f92672">=</span> 0<span style="color:#f92672">,</span>high <span style="color:#f92672">=</span> list<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>low <span style="color:#f92672">&lt;</span> high<span style="color:#f92672">){</span>
            <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> low <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>high <span style="color:#f92672">-</span> low<span style="color:#f92672">)/</span>2<span style="color:#f92672">;</span>
            Integer value <span style="color:#f92672">=</span> list<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>mid<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>value <span style="color:#f92672">==</span> target<span style="color:#f92672">){</span>
                <span style="color:#75715e">//命中，但是要向前搜索第一个元素
</span><span style="color:#75715e"></span>                <span style="color:#75715e">//这里high赋值为mid，代表后续将在左闭右开区间[low,mid)即闭区间[low,mid-1]中搜寻
</span><span style="color:#75715e"></span>                high <span style="color:#f92672">=</span> mid<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>value <span style="color:#f92672">&gt;</span> target<span style="color:#f92672">){</span>
                high <span style="color:#f92672">=</span> mid<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
                low <span style="color:#f92672">=</span> mid<span style="color:#f92672">+</span>1<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> low<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span><span style="color:#f92672">(){</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>numMatchingSubseq<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;abcde&#34;</span><span style="color:#f92672">,</span><span style="color:#66d9ef">new</span> String<span style="color:#f92672">[]{</span><span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;bb&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;acd&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;ace&#34;</span><span style="color:#f92672">}));</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>numMatchingSubseq<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;dsahjpjauf&#34;</span><span style="color:#f92672">,</span><span style="color:#66d9ef">new</span> String<span style="color:#f92672">[]{</span><span style="color:#e6db74">&#34;ahjpjau&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;ja&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;ahbwzgqnuk&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;tnmlanowax&#34;</span><span style="color:#f92672">}));</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>numMatchingSubseq<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;aa&#34;</span><span style="color:#f92672">,</span><span style="color:#66d9ef">new</span> String<span style="color:#f92672">[]{</span><span style="color:#e6db74">&#34;aaa&#34;</span><span style="color:#f92672">}));</span>
    <span style="color:#f92672">}</span>
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>LeetCode算法手记：777.在LR字符串中交换相邻字符</title>
            <link>https://Huang-zh.github.io/posts/leetcode777/</link>
            <pubDate>Thu, 07 Sep 2023 19:02:25 +0800</pubDate>
            
            <guid>https://Huang-zh.github.io/posts/leetcode777/</guid>
            <description>在一个由 ‘L’ , ‘R’ 和 ‘X’ 三个字符组成的字符串（例如&amp;#34;RXXLRXRXL&amp;#34;）中进行移动操作。 一次移动操作指用一个 “LX” 替换一个 “XL”，或者用一个 “XR” 替换一个 “RX”。 现给定起始字符串 start 和结束字符串 end，请编写代码，当且仅当存在一系列移动操作使得 start 可以转换成 end 时， 返回 True。 输入：start = &amp;#34;RXXLRXRXL&amp;#34;, end = &amp;#34;XRLXXRRLX&amp;#34; 输出：True 解释： 我们可以通过以下几步将 start 转换成 end： RXXLRXRXL -&amp;gt; XRXLRXRXL -&amp;gt; XRLXRXRXL -&amp;gt; XRLXXRRXL -&amp;gt; XRLXXRRLX 提示： 1 &amp;lt;= len(start) = len(end) &amp;lt;= 10000。 start 和 end 中的字符串仅限于’L’, ‘R’和’X’。 思路 如果一个start可以完成到end的转换，那么，两个字符串中L和R的相对位置一定会保持一致。
可以在start和end上分别各自定义指针i和j，跳过X直到第一个L或者R出现，此时判断s[i]和s[j]是否相等，如果不相等则不满足相对顺序，无法完成转换。
XL被LX替换，RX被XR替换，则意味着：
 如果能完成转换，最终end中第N个L的下标，只能小于或等于start中第N个L的下标，即L只允许左移或原地停留。 如果能完成转换，最终end中第M个R的下标，只能大于或等于start中第M个R的下标，即R只允许右移或原地停留。  思路递推 以题目中的start = &amp;ldquo;RXXLRXRXL&amp;rdquo;, end = &amp;ldquo;XRLXXRRLX&amp;quot;为例：</description>
            <content type="html"><![CDATA[<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">在一个由 ‘L’ , ‘R’ 和 ‘X’ 三个字符组成的字符串（例如&#34;RXXLRXRXL&#34;）中进行移动操作。
一次移动操作指用一个 “LX” 替换一个 “XL”，或者用一个 “XR” 替换一个 “RX”。
现给定起始字符串 start 和结束字符串 end，请编写代码，当且仅当存在一系列移动操作使得 start 可以转换成 end 时， 返回 True。

输入：start = &#34;RXXLRXRXL&#34;, end = &#34;XRLXXRRLX&#34;
输出：True

解释：
我们可以通过以下几步将 start 转换成 end：
RXXLRXRXL -&gt;
XRXLRXRXL -&gt;
XRLXRXRXL -&gt;
XRLXXRRXL -&gt;
XRLXXRRLX

提示：
1 &lt;= len(start) = len(end) &lt;= 10000。
start 和 end 中的字符串仅限于’L’, ‘R’和’X’。
</code></pre></div><h3 id="思路">思路</h3>
<p>如果一个start可以完成到end的转换，那么，两个字符串中L和R的相对位置一定会保持一致。</p>
<p>可以在start和end上分别各自定义指针i和j，跳过X直到第一个L或者R出现，此时判断s[i]和s[j]是否相等，如果不相等则不满足相对顺序，无法完成转换。</p>
<p>XL被LX替换，RX被XR替换，则意味着：</p>
<ul>
<li>如果能完成转换，最终end中第N个L的下标，只能小于或等于start中第N个L的下标，即L只允许左移或原地停留。</li>
<li>如果能完成转换，最终end中第M个R的下标，只能大于或等于start中第M个R的下标，即R只允许右移或原地停留。</li>
</ul>
<h4 id="思路递推">思路递推</h4>
<p>以题目中的start = &ldquo;RXXLRXRXL&rdquo;, end = &ldquo;XRLXXRRLX&quot;为例：</p>
<ul>
<li>找到第一个不为X的下标，此时i=0，j=1。</li>
<li>判断s[i] == s[j]，此时结果为true。</li>
<li>判断i和j的顺序，由于两字符均为R，R只允许右移或原地停留，即j &gt;= i，所以s[i]可以被转换至s[j]，即XR替换RX。</li>
<li>找到第二个不为X的下标，此时i=3,j=2。</li>
<li>判断s[i] == s[j]，此时结果为true。</li>
<li>判断i和j的顺序，由于两字符均为L，L只允许左移或原地停留，即j &lt;= i，所以s[i]可以被转换至s[j]，即LX替换XL。</li>
<li>找到第三个不为X的下标，此时i=4,j=5。</li>
<li>判断s[i] == s[j]，此时结果为true。</li>
<li>判断i和j的顺序，由于两字符均为R，R只允许右移或原地停留，即j &gt;= i，所以s[i]可以被转换至s[j]，即XR替换RX。</li>
<li>找到第四个不为X的下标，此时i=6,j=6。</li>
<li>判断s[i] == s[j]，此时结果为true。</li>
<li>判断i和j的顺序，由于两字符均为R，R只允许右移或原地停留，即j &gt;= i，所以s[i]可以被转换至s[j]，即原地停留。</li>
<li>找到第五个不为X的下标，此时i=8,j=7。</li>
<li>判断s[i] == s[j]，此时结果为true。</li>
<li>判断i和j的顺序，由于两字符均为L，L只允许左移或原地停留，即j &lt;= i，所以s[i]可以被转换至s[j]，即LX替换XL。</li>
<li>此时i到达末尾，完成搜索，判断i是否和j相等，只有两个指针到达同样的位置，才能完成转换。</li>
</ul>
<h3 id="代码实现">代码实现：</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">canTransform</span><span style="color:#f92672">(</span>String start<span style="color:#f92672">,</span> String end<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> length <span style="color:#f92672">=</span> start<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">();</span>
        <span style="color:#75715e">//定义双指针i和j，分别指向start和end
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//1.分别找到start和end中第一个不为X的字符s[i]和s[j]
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//2.判断s[i]是否和s[j]相等，若不相等，则不满足相对顺序，无法完成转换
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//3.判断s[j]的顺序：L字符只允许向左转换，R字符只允许向右转换
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//同时需要注意：start和end全由X组成的情况
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">,</span>j <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">&lt;</span> length <span style="color:#f92672">||</span> j <span style="color:#f92672">&lt;</span> length<span style="color:#f92672">){</span>
            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">&lt;</span> length <span style="color:#f92672">&amp;&amp;</span> start<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>i<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;X&#39;</span><span style="color:#f92672">)</span>
                <span style="color:#75715e">//找到start中第一个不为X的字符位置
</span><span style="color:#75715e"></span>                i<span style="color:#f92672">++;</span>
            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>j <span style="color:#f92672">&lt;</span> length <span style="color:#f92672">&amp;&amp;</span> end<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>j<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;X&#39;</span><span style="color:#f92672">)</span>
                <span style="color:#75715e">//找到end中第一个不为X的字符位置
</span><span style="color:#75715e"></span>                j<span style="color:#f92672">++;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">==</span> length <span style="color:#f92672">||</span> j <span style="color:#f92672">==</span> length<span style="color:#f92672">)</span>
                <span style="color:#75715e">//任意一边指针到头，说明当前字符串全由X组成，则另一个字符串也应该全由X组成才能完成转换
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> i <span style="color:#f92672">==</span> j<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>start<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>i<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> end<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>j<span style="color:#f92672">))</span>
                <span style="color:#75715e">//判断s[i]是否和s[j]相等，若不相等，则不满足相对顺序，无法完成转换
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>start<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>i<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;L&#39;</span> <span style="color:#f92672">&amp;&amp;</span> i <span style="color:#f92672">&lt;</span> j<span style="color:#f92672">)</span>
                <span style="color:#75715e">//L字符只允许向左转换，即转换后的下标j不应该大于i
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>start<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>i<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;R&#39;</span> <span style="color:#f92672">&amp;&amp;</span> i <span style="color:#f92672">&gt;</span> j<span style="color:#f92672">)</span>
                <span style="color:#75715e">//R字符只允许向左转换，即转换后的下标j不应该小于i
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
            i<span style="color:#f92672">++;</span>
            j<span style="color:#f92672">++;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> i <span style="color:#f92672">==</span> j<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span><span style="color:#f92672">(){</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>canTransform<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;RXXLRXRXL&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;XRLXXRRLX&#34;</span><span style="color:#f92672">));</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>canTransform<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;RXXLRXRXL&#34;</span><span style="color:#f92672">,</span><span style="color:#e6db74">&#34;XRXLXRLLX&#34;</span><span style="color:#f92672">));</span>
    <span style="color:#f92672">}</span>
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>LeetCode算法手记：658.找到 K 个最接近的元素</title>
            <link>https://Huang-zh.github.io/posts/leetcode658/</link>
            <pubDate>Tue, 05 Sep 2023 21:16:44 +0800</pubDate>
            
            <guid>https://Huang-zh.github.io/posts/leetcode658/</guid>
            <description>给定一个排序好的数组 arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。
整数 a 比整数 b 更接近 x 需要满足：
  |a - x| &amp;lt; |b - x| 或者
  |a - x| == |b - x| 且 a &amp;lt; b
  示例 1：
输入：arr = [1,2,3,4,5], k = 4, x = 3
输出：[1,2,3,4]
示例 2：
输入：arr = [1,2,3,4,5], k = 4, x = -1
输出：[1,2,3,4]
提示：
1 &amp;lt;= k &amp;lt;= arr.</description>
            <content type="html"><![CDATA[<blockquote>
<p>给定一个排序好的数组 arr ，两个整数 k 和 x ，从数组中找到最靠近 x（两数之差最小）的 k 个数。返回的结果必须要是按升序排好的。</p>
<p>整数 a 比整数 b 更接近 x 需要满足：</p>
<ul>
<li>
<p>|a - x| &lt; |b - x| 或者</p>
</li>
<li>
<p>|a - x| == |b - x| 且 a &lt; b</p>
</li>
</ul>
<p>示例 1：</p>
<p>输入：arr = [1,2,3,4,5], k = 4, x = 3</p>
<p>输出：[1,2,3,4]</p>
<p>示例 2：</p>
<p>输入：arr = [1,2,3,4,5], k = 4, x = -1</p>
<p>输出：[1,2,3,4]</p>
<p>提示：</p>
<p>1 &lt;= k &lt;= arr.length</p>
<p>1 &lt;= arr.length &lt;= 104</p>
<p>arr 按升序排列</p>
<p>-104 &lt;= arr[i], x &lt;= 104</p>
</blockquote>
<h3 id="思路">思路</h3>
<p>找到数组中从左到右第一次出现x的下标（index），在该下标的左右维护两个指针，分别向左和向右递进来寻找其他更贴近的元素。</p>
<h4 id="思路递推">思路递推</h4>
<p>以[1,2,3,4,5,5,5,6,8]为例，k为4，x为5，即寻找4个最接近5的数字，并由小到大排序返回。可以知道index为4，此时维护left指针为index-1即3，right指针为index即4，开始递进指针，过程如下：</p>
<ol>
<li>left = 3，right = 4，判断此时两指针元素与x的差值，发现right处的差值为0，即差值更小，则将right指针向右递进为5。</li>
<li>left = 3，right = 5，判断此时两指针元素与x的差值，发现right处的差值为0，即差值更小，则将right指针向右递进为6。</li>
<li>left = 3，right = 6，判断此时两指针元素与x的差值，发现right处的差值为0，即差值更小，则将right指针向右递进为7。</li>
<li>left = 3，right = 7，判断此时两指针元素与x的差值，发现两处的差值均为1，即差值相等，根据提议，差值相等时更接近的值需要有更小的下标，则将left指针向左递进为2。</li>
<li>满足4个数字，退出搜寻。</li>
</ol>
<p>此时还要注意几个边界值：</p>
<ul>
<li>左右指针不能够越出数组边界，当一侧到达边界时，即代表该侧无法再获取接近的值，只需要递进另一侧的指针，从另一侧获取更接近的值。</li>
<li>怎么退出搜寻？不难发现可以通过k的递减来实现循环控制，由于right一开始值为index，即代表right指针一开始对应的元素肯定会被纳入结果，所以循环实际上只用进行k-1次。</li>
</ul>
<h3 id="代码实现">代码实现：</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LeetCode658</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">findClosestElements</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> k<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> x<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">//找到数组中最左端x对应的下标index
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//在index左右分别维护双指针left和right，其中left指针向左递进，right指针从index向右递进
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//在递进的过程中判断两边的差值，差值较小的一侧表明更接近x，对应侧的指针继续递进寻找下一个更接近的值
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//递进的过程中注意判断是否超出数组边界，若当前侧超出数组边界则另一侧指针递进，直到right-left = k为止
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> leftBondBinarySearch<span style="color:#f92672">(</span>arr<span style="color:#f92672">,</span> x<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> index <span style="color:#f92672">-</span> 1<span style="color:#f92672">,</span>right <span style="color:#f92672">=</span> index<span style="color:#f92672">;</span>
        List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> result <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>
        <span style="color:#75715e">//循环只能进行k-1次，因为一开始right下标对应的元素就是本身，即差值为0，肯定会被纳入结果，因此只要再找出k-1个数即可
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>k<span style="color:#f92672">--</span> <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">){</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>left <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span>
                <span style="color:#75715e">//超出左边界，右侧指针递进
</span><span style="color:#75715e"></span>                right<span style="color:#f92672">++;</span>
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>right <span style="color:#f92672">&gt;</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">)</span>
                <span style="color:#75715e">//超出右边界，左侧指针递进
</span><span style="color:#75715e"></span>                left<span style="color:#f92672">--;</span>
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x <span style="color:#f92672">-</span> arr<span style="color:#f92672">[</span>left<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;=</span> arr<span style="color:#f92672">[</span>right<span style="color:#f92672">]</span> <span style="color:#f92672">-</span> x<span style="color:#f92672">)</span>
                <span style="color:#75715e">//两侧差值取小的一侧递进，如果相等则取下标更小的元素
</span><span style="color:#75715e"></span>                left<span style="color:#f92672">--;</span>
            <span style="color:#66d9ef">else</span>
                right<span style="color:#f92672">++;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#75715e">//此时left和right的差值为k+1，从left+1处开始获取第一个元素
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> left<span style="color:#f92672">+</span>1<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> right<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            result<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>arr<span style="color:#f92672">[</span>i<span style="color:#f92672">]);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> result<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * @Author huang.zh
</span><span style="color:#75715e">     * @Description 找到数组中最左端出现的值为target的元素下标，即二分左边界搜索
</span><span style="color:#75715e">     * @Date 9:43 PM 2023/9/5
</span><span style="color:#75715e">     * @Param [arr, target]
</span><span style="color:#75715e">     * @return
</span><span style="color:#75715e">     **/</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">leftBondBinarySearch</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">,</span><span style="color:#66d9ef">int</span> target<span style="color:#f92672">){</span>
        <span style="color:#66d9ef">int</span> left <span style="color:#f92672">=</span> 0<span style="color:#f92672">,</span>right <span style="color:#f92672">=</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>left <span style="color:#f92672">&lt;</span> right<span style="color:#f92672">){</span>
            <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> left <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>right <span style="color:#f92672">-</span> left<span style="color:#f92672">)/</span>2<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>arr<span style="color:#f92672">[</span>mid<span style="color:#f92672">]</span> <span style="color:#f92672">==</span> target<span style="color:#f92672">){</span>
                <span style="color:#75715e">//命中元素，右指针重置，在[left,mid]中寻找更左端的值为target的元素
</span><span style="color:#75715e"></span>                right <span style="color:#f92672">=</span> mid<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>arr<span style="color:#f92672">[</span>mid<span style="color:#f92672">]</span> <span style="color:#f92672">&lt;</span> target<span style="color:#f92672">){</span>
                left <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
                right <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> left<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>


    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test</span><span style="color:#f92672">(){</span>
        List<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> findClosestElements<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]{</span>1<span style="color:#f92672">,</span> 2<span style="color:#f92672">,</span> 3<span style="color:#f92672">,</span> 4<span style="color:#f92672">,</span> 5<span style="color:#f92672">},</span> 2<span style="color:#f92672">,</span> 4<span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">(</span>list<span style="color:#f92672">.</span><span style="color:#a6e22e">toArray</span><span style="color:#f92672">()));</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>Redis存储原理剖析&lt;三&gt;：key的惰性删除--异步删除策略</title>
            <link>https://Huang-zh.github.io/posts/redis3/</link>
            <pubDate>Fri, 01 Sep 2023 10:10:44 +0800</pubDate>
            
            <guid>https://Huang-zh.github.io/posts/redis3/</guid>
            <description>前面我们介绍了key在惰性删除时同步删除过程的实现，具体可见：
 Redis存储原理剖析&amp;lt;二&amp;gt;：key的惰性删除&amp;ndash;同步删除策略  本篇文章，我们将继续探索惰性删除时，key的异步删除过程的实现。
6.1.2 异步删除 直接看异步删除的代码：
#define LAZYFREE_THRESHOLD 64 int dbAsyncDelete(redisDb *db, robj *key) { // 第一步，进行expireDict的删除，仍旧保留dataDict中的dictEntry  if (dictSize(db-&amp;gt;expires) &amp;gt; 0) dictDelete(db-&amp;gt;expires,key-&amp;gt;ptr); // 第二步，进行unlink操作，只是简单的把dataDict内部hash桶里的链表解链  // 内部调用的dictGenericDelete函数在同步删除代码中分析过，区别是此处nofree传入的值为1，即不进行内存释放  dictEntry *de = dictUnlink(db-&amp;gt;dict,key-&amp;gt;ptr); if (de) { robj *val = dictGetVal(de); // 计算当前释放value内存需要的开销，根据value的类型会得到不同的开销  size_t free_effort = lazyfreeGetFreeEffort(val); // 第三步，如果开销过大，并且当前引用计数为1，添加任务调度进行异步释放value  if (free_effort &amp;gt; LAZYFREE_THRESHOLD &amp;amp;&amp;amp; val-&amp;gt;refcount == 1) { atomicIncr(lazyfree_objects,1); bioCreateBackgroundJob(BIO_LAZY_FREE,val,NULL,NULL); dictSetVal(db-&amp;gt;dict,de,NULL); } } // 如果此时dictEntry仍未被释放/或是开销不大，触发兜底机制，直接调用dictFreeUnlinkedEntry进行key和value以及dictEntry的释放  // dictFreeUnlinkedEntry内部仍旧调用dictFreeKey，dictFreeVal，zfree，在同步删除中已经分析过  if (de) { dictFreeUnlinkedEntry(db-&amp;gt;dict,de); //集群模式下，寻找对应的slot进行remove操作  if (server.</description>
            <content type="html"><![CDATA[<p>前面我们介绍了key在惰性删除时同步删除过程的实现，具体可见：</p>
<ul>
<li><a href="/posts/redis2">Redis存储原理剖析&lt;二&gt;：key的惰性删除&ndash;同步删除策略</a></li>
</ul>
<p>本篇文章，我们将继续探索惰性删除时，key的异步删除过程的实现。</p>
<h5 id="612-异步删除">6.1.2 异步删除</h5>
<p>直接看异步删除的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#define LAZYFREE_THRESHOLD 64
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dbAsyncDelete</span>(redisDb <span style="color:#f92672">*</span>db, robj <span style="color:#f92672">*</span>key) {
    <span style="color:#75715e">// 第一步，进行expireDict的删除，仍旧保留dataDict中的dictEntry
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (dictSize(db<span style="color:#f92672">-&gt;</span>expires) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) dictDelete(db<span style="color:#f92672">-&gt;</span>expires,key<span style="color:#f92672">-&gt;</span>ptr);
		<span style="color:#75715e">// 第二步，进行unlink操作，只是简单的把dataDict内部hash桶里的链表解链
</span><span style="color:#75715e"></span>  	<span style="color:#75715e">// 内部调用的dictGenericDelete函数在同步删除代码中分析过，区别是此处nofree传入的值为1，即不进行内存释放
</span><span style="color:#75715e"></span>    dictEntry <span style="color:#f92672">*</span>de <span style="color:#f92672">=</span> dictUnlink(db<span style="color:#f92672">-&gt;</span>dict,key<span style="color:#f92672">-&gt;</span>ptr);
    <span style="color:#66d9ef">if</span> (de) {
        robj <span style="color:#f92672">*</span>val <span style="color:#f92672">=</span> dictGetVal(de);
      	<span style="color:#75715e">// 计算当前释放value内存需要的开销，根据value的类型会得到不同的开销
</span><span style="color:#75715e"></span>        size_t free_effort <span style="color:#f92672">=</span> lazyfreeGetFreeEffort(val);

       	<span style="color:#75715e">// 第三步，如果开销过大，并且当前引用计数为1，添加任务调度进行异步释放value
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (free_effort <span style="color:#f92672">&gt;</span> LAZYFREE_THRESHOLD <span style="color:#f92672">&amp;&amp;</span> val<span style="color:#f92672">-&gt;</span>refcount <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
            atomicIncr(lazyfree_objects,<span style="color:#ae81ff">1</span>);
            bioCreateBackgroundJob(BIO_LAZY_FREE,val,NULL,NULL);
            dictSetVal(db<span style="color:#f92672">-&gt;</span>dict,de,NULL);
        }
    }

    <span style="color:#75715e">// 如果此时dictEntry仍未被释放/或是开销不大，触发兜底机制，直接调用dictFreeUnlinkedEntry进行key和value以及dictEntry的释放
</span><span style="color:#75715e"></span>  	<span style="color:#75715e">// dictFreeUnlinkedEntry内部仍旧调用dictFreeKey，dictFreeVal，zfree，在同步删除中已经分析过
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (de) {
        dictFreeUnlinkedEntry(db<span style="color:#f92672">-&gt;</span>dict,de);
      	<span style="color:#75715e">//集群模式下，寻找对应的slot进行remove操作
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (server.cluster_enabled) slotToKeyDel(key);
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    }
}
</code></pre></div><p>可以看到异步删除的过程中,添加异步任务的前置条件仍旧是引用计数,至于添加异步调度任务,核心代码在bioCreateBackgroundJob中,实际上就是调用了操作系统提供的标准库函数加锁,成功加锁后往类型为释放内存的任务队列中添加一个新的任务:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bioCreateBackgroundJob</span>(<span style="color:#66d9ef">int</span> type, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg1, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg2, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg3) {
  	<span style="color:#75715e">//构造一个job
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> bio_job <span style="color:#f92672">*</span>job <span style="color:#f92672">=</span> zmalloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>job));
		<span style="color:#75715e">//为当前的任务设置任务创建时间
</span><span style="color:#75715e"></span>    job<span style="color:#f92672">-&gt;</span>time <span style="color:#f92672">=</span> time(NULL);
    <span style="color:#75715e">//任务参数赋值
</span><span style="color:#75715e"></span>    job<span style="color:#f92672">-&gt;</span>arg1 <span style="color:#f92672">=</span> arg1;
    job<span style="color:#f92672">-&gt;</span>arg2 <span style="color:#f92672">=</span> arg2;
    job<span style="color:#f92672">-&gt;</span>arg3 <span style="color:#f92672">=</span> arg3;
  	<span style="color:#75715e">//获取互斥锁 
</span><span style="color:#75715e"></span>    pthread_mutex_lock(<span style="color:#f92672">&amp;</span>bio_mutex[type]);
  	<span style="color:#75715e">//bio_jobs为二级指针,可以理解为二维数组,由任务类型定位到具体存储的队列,将任务添加至队尾
</span><span style="color:#75715e"></span>    listAddNodeTail(bio_jobs[type],job);
    bio_pending[type]<span style="color:#f92672">++</span>;
  	<span style="color:#75715e">//唤醒阻塞线程,阻塞的线程会从cond_wait队列切换至mutex_lock队列,尝试争抢互斥锁
</span><span style="color:#75715e"></span>    pthread_cond_signal(<span style="color:#f92672">&amp;</span>bio_newjob_cond[type]);
    <span style="color:#75715e">//解锁
</span><span style="color:#75715e"></span>    pthread_mutex_unlock(<span style="color:#f92672">&amp;</span>bio_mutex[type]);
}
</code></pre></div><p>那么，既然调度任务进入队列，就一定会有出队的时候。bioCreateBackgroundJob所在的文件为bio.c，bio全称background io，作为redis的后台io线程，支撑着redis-server运行时所有的异步任务调度。bio.c中存在这样一个函数bioProcessBackgroundJobs，就是它从任务队列中拿出创建的调度任务并执行，这个函数在redis-server启动时就会被调用，redis-server启动的入口，就在server.c中的main函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv) {
    ......
    <span style="color:#75715e">// 检查是否启用哨兵模式
</span><span style="color:#75715e"></span>    server.sentinel_mode <span style="color:#f92672">=</span> checkForSentinelMode(argc,argv);
  	<span style="color:#75715e">// 加载配置项
</span><span style="color:#75715e"></span>    initServerConfig();
   	......


  	<span style="color:#75715e">// server初始化，分配hashtable的内存，初始化loop线程
</span><span style="color:#75715e"></span>    initServer();
    ......
    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>server.sentinel_mode) {
      	......
        InitServerLast();
      	<span style="color:#75715e">//从磁盘恢复数据，模式可以为RDB或AOF
</span><span style="color:#75715e"></span>        loadDataFromDisk();
        <span style="color:#66d9ef">if</span> (server.cluster_enabled) {
            <span style="color:#66d9ef">if</span> (verifyClusterConfigWithData() <span style="color:#f92672">==</span> C_ERR) {
                serverLog(LL_WARNING,
                    <span style="color:#e6db74">&#34;You can&#39;t have keys in a DB different than DB 0 when in &#34;</span>
                    <span style="color:#e6db74">&#34;Cluster mode. Exiting.&#34;</span>);
                exit(<span style="color:#ae81ff">1</span>);
            }
        }
        <span style="color:#66d9ef">if</span> (server.ipfd_count <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
            serverLog(LL_NOTICE,<span style="color:#e6db74">&#34;Ready to accept connections&#34;</span>);
        <span style="color:#66d9ef">if</span> (server.sofd <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>)
            serverLog(LL_NOTICE,<span style="color:#e6db74">&#34;The server is now ready to accept connections at %s&#34;</span>, server.unixsocket);
    } <span style="color:#66d9ef">else</span> {
        InitServerLast();
        sentinelIsRunning();
    }

    <span style="color:#66d9ef">if</span> (server.maxmemory <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> server.maxmemory <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1024</span><span style="color:#f92672">*</span><span style="color:#ae81ff">1024</span>) {
        serverLog(LL_WARNING,<span style="color:#e6db74">&#34;WARNING: You specified a maxmemory value that is less than 1MB (current value is %llu bytes). Are you sure this is what you really want?&#34;</span>, server.maxmemory);
    }

    aeSetBeforeSleepProc(server.el,beforeSleep);
    aeSetAfterSleepProc(server.el,afterSleep);
    aeMain(server.el);
    aeDeleteEventLoop(server.el);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>不论是单机模式还是哨兵集群模式，都会调用InitServerLast进行server初始化：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">InitServerLast</span>() {
    bioInit();
    server.initial_memory_usage <span style="color:#f92672">=</span> zmalloc_used_memory();
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bioInit</span>(<span style="color:#66d9ef">void</span>) {
    pthread_attr_t attr;
    pthread_t <span style="color:#66d9ef">thread</span>;
    size_t stacksize;
    <span style="color:#66d9ef">int</span> j;

    <span style="color:#75715e">//BIO_NUM_OPS默认值为3，也就意味着通过pthread孵化了三组调度线程模型，它们分别对应着三种不同类型的调度任务
</span><span style="color:#75715e"></span>  	<span style="color:#75715e">//每一组线程调度模型有着自己的互斥锁、任务队列为空等待条件、线程唤醒条件，分别对应bio_mutex、bio_newjob_cond、bio_step_cond
</span><span style="color:#75715e"></span>  	<span style="color:#75715e">//bio_jobs为具体的任务队列，由listCreate创建的一个含有头尾指针的链表
</span><span style="color:#75715e"></span>  	<span style="color:#75715e">//bio_pending存储每种类型的任务等待处理的数量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> BIO_NUM_OPS; j<span style="color:#f92672">++</span>) {
        pthread_mutex_init(<span style="color:#f92672">&amp;</span>bio_mutex[j],NULL);
        pthread_cond_init(<span style="color:#f92672">&amp;</span>bio_newjob_cond[j],NULL);
        pthread_cond_init(<span style="color:#f92672">&amp;</span>bio_step_cond[j],NULL);
        bio_jobs[j] <span style="color:#f92672">=</span> listCreate();
        bio_pending[j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    }

    ......
      
    <span style="color:#66d9ef">for</span> (j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> BIO_NUM_OPS; j<span style="color:#f92672">++</span>) {
        <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg <span style="color:#f92672">=</span> (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>) j;
      	<span style="color:#75715e">//每种类型创建一个loop线程，调用bioProcessBackgroundJobs进行任务调度
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (pthread_create(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">thread</span>,<span style="color:#f92672">&amp;</span>attr,bioProcessBackgroundJobs,arg) <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
            serverLog(LL_WARNING,<span style="color:#e6db74">&#34;Fatal: Can&#39;t initialize Background Jobs.&#34;</span>);
            exit(<span style="color:#ae81ff">1</span>);
        }
        bio_threads[j] <span style="color:#f92672">=</span> <span style="color:#66d9ef">thread</span>;
    }
} 
</code></pre></div><p>到了bioProcessBackgroundJobs这一层，开始真正的任务调度过程：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">bioProcessBackgroundJobs</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>arg) {
    <span style="color:#66d9ef">struct</span> bio_job <span style="color:#f92672">*</span>job;
  	<span style="color:#75715e">//type为任务的类型
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> type <span style="color:#f92672">=</span> (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>) arg;
    sigset_t sigset;

    <span style="color:#75715e">//任务类型校验合法性
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (type <span style="color:#f92672">&gt;=</span> BIO_NUM_OPS) {
        serverLog(LL_WARNING,
            <span style="color:#e6db74">&#34;Warning: bio thread started with wrong type %lu&#34;</span>,type);
        <span style="color:#66d9ef">return</span> NULL;
    }

  	<span style="color:#75715e">//设置线程属性，让线程可以被中断
</span><span style="color:#75715e"></span>    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
    pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
		<span style="color:#75715e">//获取互斥锁
</span><span style="color:#75715e"></span>    pthread_mutex_lock(<span style="color:#f92672">&amp;</span>bio_mutex[type]);

    sigemptyset(<span style="color:#f92672">&amp;</span>sigset);
    sigaddset(<span style="color:#f92672">&amp;</span>sigset, SIGALRM);
    <span style="color:#66d9ef">if</span> (pthread_sigmask(SIG_BLOCK, <span style="color:#f92672">&amp;</span>sigset, NULL))
        serverLog(LL_WARNING,
            <span style="color:#e6db74">&#34;Warning: can&#39;t mask SIGALRM in bio.c thread: %s&#34;</span>, strerror(errno));

    <span style="color:#66d9ef">while</span>(<span style="color:#ae81ff">1</span>) {
        listNode <span style="color:#f92672">*</span>ln;

        
        <span style="color:#66d9ef">if</span> (listLength(bio_jobs[type]) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
          	<span style="color:#75715e">//如果当前type对应的任务队列为空，当前线程占有互斥锁并等待
</span><span style="color:#75715e"></span>            pthread_cond_wait(<span style="color:#f92672">&amp;</span>bio_newjob_cond[type],<span style="color:#f92672">&amp;</span>bio_mutex[type]);
            <span style="color:#66d9ef">continue</span>;
        }
        <span style="color:#75715e">//直到任务队列不为空，获取头节点，占有互斥锁的线程将在这一步获得job
</span><span style="color:#75715e"></span>        ln <span style="color:#f92672">=</span> listFirst(bio_jobs[type]);
        job <span style="color:#f92672">=</span> ln<span style="color:#f92672">-&gt;</span>value;
        
      	<span style="color:#75715e">//获取到任务后释放互斥锁
</span><span style="color:#75715e"></span>        pthread_mutex_unlock(<span style="color:#f92672">&amp;</span>bio_mutex[type]);

        <span style="color:#75715e">//根据类型处理任务调度，这里我们传入的type为BIO_LAZY_FREE，代表释放内存类型的任务
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (type <span style="color:#f92672">==</span> BIO_CLOSE_FILE) {
            close((<span style="color:#66d9ef">long</span>)job<span style="color:#f92672">-&gt;</span>arg1);
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (type <span style="color:#f92672">==</span> BIO_AOF_FSYNC) {
            redis_fsync((<span style="color:#66d9ef">long</span>)job<span style="color:#f92672">-&gt;</span>arg1);
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (type <span style="color:#f92672">==</span> BIO_LAZY_FREE) {
            <span style="color:#75715e">//根据参数来调用不同的释放函数
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (job<span style="color:#f92672">-&gt;</span>arg1)
              	<span style="color:#75715e">//释放指针指向的对象内存
</span><span style="color:#75715e"></span>                lazyfreeFreeObjectFromBioThread(job<span style="color:#f92672">-&gt;</span>arg1);
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (job<span style="color:#f92672">-&gt;</span>arg2 <span style="color:#f92672">&amp;&amp;</span> job<span style="color:#f92672">-&gt;</span>arg3)
              	<span style="color:#75715e">//清除一个dict中的两个hashTable，即dataDict和expireDict，也就是ht[2]
</span><span style="color:#75715e"></span>                lazyfreeFreeDatabaseFromBioThread(job<span style="color:#f92672">-&gt;</span>arg2,job<span style="color:#f92672">-&gt;</span>arg3);
            <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (job<span style="color:#f92672">-&gt;</span>arg3)
              	<span style="color:#75715e">//清除zset的底层实现：skipList
</span><span style="color:#75715e"></span>                lazyfreeFreeSlotsMapFromBioThread(job<span style="color:#f92672">-&gt;</span>arg3);
        } <span style="color:#66d9ef">else</span> {
            serverPanic(<span style="color:#e6db74">&#34;Wrong job type in bioProcessBackgroundJobs().&#34;</span>);
        }
      	<span style="color:#75715e">//释放调度任务占用的内存
</span><span style="color:#75715e"></span>        zfree(job);

        <span style="color:#75715e">//再次获取互斥锁，配合循环中空任务队列等待条件使用
</span><span style="color:#75715e"></span>        pthread_mutex_lock(<span style="color:#f92672">&amp;</span>bio_mutex[type]);
      	<span style="color:#75715e">//任务队列出队
</span><span style="color:#75715e"></span>        listDelNode(bio_jobs[type],ln);
      	<span style="color:#75715e">//正在等待处理的任务数-1
</span><span style="color:#75715e"></span>        bio_pending[type]<span style="color:#f92672">--</span>;

        pthread_cond_broadcast(<span style="color:#f92672">&amp;</span>bio_step_cond[type]);
    }
}
</code></pre></div><p>在异步删除的代码中很明显看到只传入了一个arg1的值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">bioCreateBackgroundJob(BIO_LAZY_FREE,val,NULL,NULL);
</code></pre></div><p>因此可以推断出在任务调度过程中会调用lazyfreeFreeObjectFromBioThread方法进行内存释放：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">lazyfreeFreeObjectFromBioThread</span>(robj <span style="color:#f92672">*</span>o) {
    decrRefCount(o);
    atomicDecr(lazyfree_objects,<span style="color:#ae81ff">1</span>);
}
</code></pre></div><p>也是调用了decrRefCount，针对不同类型的value值，调用不同的释放内存函数。</p>
<p>所以不论是同步删除还是异步删除的方式，二者都是针对key所在的sds内存释放，和value不同类型的内存释放，底层最终都是会调用zfree进行内存释放，zfree封装了操作系统提供的free接口。</p>
<p>至此，惰性删除的流程，以及底层函数的调用已经分析完毕。</p>
]]></content>
        </item>
        
        <item>
            <title>Redis存储原理剖析&lt;二&gt;：key的惰性删除--同步删除策略</title>
            <link>https://Huang-zh.github.io/posts/redis2/</link>
            <pubDate>Tue, 29 Aug 2023 19:10:44 +0800</pubDate>
            
            <guid>https://Huang-zh.github.io/posts/redis2/</guid>
            <description>6. key删除策略 redis中，对于过期key的淘汰机制，可以分为以下两种：
 定期删除：一种主动删除策略，定期去轮询存储了key的过期时间的字典。 惰性删除：在寻找/写入dictEntry的时候判断是否过期，属于被动删除策略。  6.1 惰性删除 惰性删除的代码，入口在db.c中的expireIfNeeded，该方法由执行查找命令或写入命令的方法调用，在执行真正的命令之前，做key的删除判断以及删除操作：
int expireIfNeeded(redisDb *db, robj *key) { //设定了过期时间且未过期的key会在这一步直接返回  if (!keyIsExpired(db,key)) return 0; //当前redis节点过期了，但是存在master节点。  //意味着当前属于slave节点，返回1，由master执行删除后同步至slave  if (server.masterhost != NULL) return 1; //过期key的数量+1  server.stat_expiredkeys++; //把过期的key的消息传播到slave，同时将该key的删除命令写入到aof文件  propagateExpire(db,key,server.lazyfree_lazy_expire); //通知监听了该key的客户端，通知key的过期事件  notifyKeyspaceEvent(NOTIFY_EXPIRED, &amp;#34;expired&amp;#34;,key,db-&amp;gt;id); //根据设定的删除方式，决定采用同步删除还是异步删除  return server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) : dbSyncDelete(db,key); } int keyIsExpired(redisDb *db, robj *key) { //获得设定的过期时间戳  mstime_t when = getExpire(db,key); mstime_t now; //如果时间戳小于0，说明没有设置过期时间  if (when &amp;lt; 0) return 0; //loading状态下不允许进行过期判断  if (server.</description>
            <content type="html"><![CDATA[<h3 id="6-key删除策略">6. key删除策略</h3>
<p>redis中，对于过期key的淘汰机制，可以分为以下两种：</p>
<ul>
<li>定期删除：一种主动删除策略，定期去轮询存储了key的过期时间的字典。</li>
<li>惰性删除：在寻找/写入dictEntry的时候判断是否过期，属于被动删除策略。</li>
</ul>
<h4 id="61-惰性删除">6.1 惰性删除</h4>
<p>惰性删除的代码，入口在db.c中的expireIfNeeded，该方法由执行查找命令或写入命令的方法调用，在执行真正的命令之前，做key的删除判断以及删除操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">expireIfNeeded</span>(redisDb <span style="color:#f92672">*</span>db, robj <span style="color:#f92672">*</span>key) {
  	<span style="color:#75715e">//设定了过期时间且未过期的key会在这一步直接返回
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>keyIsExpired(db,key)) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
		<span style="color:#75715e">//当前redis节点过期了，但是存在master节点。
</span><span style="color:#75715e"></span>  	<span style="color:#75715e">//意味着当前属于slave节点，返回1，由master执行删除后同步至slave
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (server.masterhost <span style="color:#f92672">!=</span> NULL) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
  	
  	<span style="color:#75715e">//过期key的数量+1
</span><span style="color:#75715e"></span>    server.stat_expiredkeys<span style="color:#f92672">++</span>;
  	
  	<span style="color:#75715e">//把过期的key的消息传播到slave，同时将该key的删除命令写入到aof文件
</span><span style="color:#75715e"></span>    propagateExpire(db,key,server.lazyfree_lazy_expire);
  	<span style="color:#75715e">//通知监听了该key的客户端，通知key的过期事件
</span><span style="color:#75715e"></span>    notifyKeyspaceEvent(NOTIFY_EXPIRED,
        <span style="color:#e6db74">&#34;expired&#34;</span>,key,db<span style="color:#f92672">-&gt;</span>id);
  	<span style="color:#75715e">//根据设定的删除方式，决定采用同步删除还是异步删除
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> server.lazyfree_lazy_expire <span style="color:#f92672">?</span> dbAsyncDelete(db,key) <span style="color:#f92672">:</span>
                                         dbSyncDelete(db,key);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">keyIsExpired</span>(redisDb <span style="color:#f92672">*</span>db, robj <span style="color:#f92672">*</span>key) {
  	<span style="color:#75715e">//获得设定的过期时间戳
</span><span style="color:#75715e"></span>    mstime_t when <span style="color:#f92672">=</span> getExpire(db,key);
    mstime_t now;
		<span style="color:#75715e">//如果时间戳小于0，说明没有设置过期时间
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (when <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>; 

    <span style="color:#75715e">//loading状态下不允许进行过期判断
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (server.loading) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;

    <span style="color:#75715e">//获得系统当前时间
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (server.lua_caller) {
        now <span style="color:#f92672">=</span> server.lua_time_start;
    }
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (server.fixed_time_expire <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) {
        now <span style="color:#f92672">=</span> server.mstime;
    }
    <span style="color:#66d9ef">else</span> {
        now <span style="color:#f92672">=</span> mstime();
    }

    <span style="color:#75715e">//执行判断
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> now <span style="color:#f92672">&gt;</span> when;
}

<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> <span style="color:#a6e22e">getExpire</span>(redisDb <span style="color:#f92672">*</span>db, robj <span style="color:#f92672">*</span>key) {
    dictEntry <span style="color:#f92672">*</span>de;

   	<span style="color:#75715e">//如果存储expireTime的字典为空 或者 当前key没有设置过期时间，返回-1
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (dictSize(db<span style="color:#f92672">-&gt;</span>expires) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span>
       (de <span style="color:#f92672">=</span> dictFind(db<span style="color:#f92672">-&gt;</span>expires,key<span style="color:#f92672">-&gt;</span>ptr)) <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;

    <span style="color:#75715e">//安全保护机制，确保存储在expireDict中的key也存在于dataDict中
</span><span style="color:#75715e"></span>    serverAssertWithInfo(NULL,key,dictFind(db<span style="color:#f92672">-&gt;</span>dict,key<span style="color:#f92672">-&gt;</span>ptr) <span style="color:#f92672">!=</span> NULL);
  	<span style="color:#75715e">//取得过期时间戳并返回
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> dictGetSignedIntegerVal(de);
}
</code></pre></div><p>简略画出这段代码调用的时序图：

<script async type="application/javascript" src="https://cdn.jsdelivr.net/npm/mermaid@9.1.1/dist/mermaid.min.js">
    var config = {
      startOnLoad:true,
      theme:'neutral',
      align:'left'
    };
    mermaid.initialize(config);
  </script>
  
  <div class="mermaid">
    
  sequenceDiagram
　　participant expireIfNeeded
　　participant keyIsExpired
　　participant getExpire
　　participant dictFind
　　expireIfNeeded->>keyIsExpired:invoke
　　keyIsExpired->>getExpire:invoke
　　getExpire->>dictFind:invoke
　　Note OVER dictFind: 从expireDict中获取value
　　dictFind-->>getExpire:return value
　　Note OVER getExpire: 解析value获取过期时间戳
　　getExpire-->>keyIsExpired:return
　　Note OVER keyIsExpired: 将时间戳和系统当前时间比较
　　keyIsExpired-->>expireIfNeeded:return
　　Note OVER expireIfNeeded: 判断是否过期、是否为master节点
　　Note OVER expireIfNeeded: 通知slave节点进行key删除，并将删除命令写入AOF文件
　　Note OVER expireIfNeeded: 向监听了key的客户端发布key过期事件
　　Note OVER expireIfNeeded: 根据预设的删除方式，选择同步或者是异步删除key对应的dictEntry

  </div>
</p>
<p>其中，在使用具体的删除方式时，涉及到一个值lazyfree_lazy_expire，它需要我们在redis.conf文件中进行配置：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">lazyfree-lazy-expire no
</code></pre></div><p>可以看到默认值为no，即代表在删除是会采用同步删除，如果将该项置为yes，则采用异步删除的模式。</p>
<p>接下来，分别来看一下同步删除和异步删除的代码实现。</p>
<h5 id="611-同步删除">6.1.1 同步删除</h5>
<p>同步删除的代码比较简单：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dbSyncDelete</span>(redisDb <span style="color:#f92672">*</span>db, robj <span style="color:#f92672">*</span>key) {
    <span style="color:#75715e">//如果expireDict大于0，先进行expireDict的删除
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (dictSize(db<span style="color:#f92672">-&gt;</span>expires) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>) dictDelete(db<span style="color:#f92672">-&gt;</span>expires,key<span style="color:#f92672">-&gt;</span>ptr);
  	<span style="color:#75715e">//再进行dataDict的删除
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (dictDelete(db<span style="color:#f92672">-&gt;</span>dict,key<span style="color:#f92672">-&gt;</span>ptr) <span style="color:#f92672">==</span> DICT_OK) {
      	<span style="color:#75715e">//如果当前是集群模式，则定位到具体存储dictEntry的slot，进行remove操作
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (server.cluster_enabled) slotToKeyDel(key);
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dictDelete</span>(dict <span style="color:#f92672">*</span>ht, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key) {
    <span style="color:#66d9ef">return</span> dictGenericDelete(ht,key,<span style="color:#ae81ff">0</span>) <span style="color:#f92672">?</span> DICT_OK : DICT_ERR;
}

<span style="color:#66d9ef">static</span> dictEntry <span style="color:#f92672">*</span><span style="color:#a6e22e">dictGenericDelete</span>(dict <span style="color:#f92672">*</span>d, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key, <span style="color:#66d9ef">int</span> nofree) {
    <span style="color:#66d9ef">uint64_t</span> h, idx;
    dictEntry <span style="color:#f92672">*</span>he, <span style="color:#f92672">*</span>prevHe;
    <span style="color:#66d9ef">int</span> table;
		<span style="color:#75715e">//dataDict和expireDict同时为空的情况下直接返回NULL
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].used <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">1</span>].used <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> NULL;
		<span style="color:#75715e">//判断是否正在扩容，如果正在扩容则帮助推进hashTable的expand过程
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (dictIsRehashing(d)) _dictRehashStep(d);
  	<span style="color:#75715e">//得到hash值
</span><span style="color:#75715e"></span>    h <span style="color:#f92672">=</span> dictHashKey(d, key);

    <span style="color:#66d9ef">for</span> (table <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; table <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>; table<span style="color:#f92672">++</span>) {
        idx <span style="color:#f92672">=</span> h <span style="color:#f92672">&amp;</span> d<span style="color:#f92672">-&gt;</span>ht[table].sizemask;
      	<span style="color:#75715e">//定位到存储在hash桶中的链表头节点
</span><span style="color:#75715e"></span>        he <span style="color:#f92672">=</span> d<span style="color:#f92672">-&gt;</span>ht[table].table[idx];
        prevHe <span style="color:#f92672">=</span> NULL;
      	<span style="color:#75715e">//开始从链表的头部开始，依次向后查找
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">while</span>(he) {
            <span style="color:#66d9ef">if</span> (key<span style="color:#f92672">==</span>he<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">||</span> dictCompareKeys(d, key, he<span style="color:#f92672">-&gt;</span>key)) {
              	<span style="color:#75715e">//链表解链操作
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (prevHe)
                    prevHe<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> he<span style="color:#f92672">-&gt;</span>next;
                <span style="color:#66d9ef">else</span>
                    d<span style="color:#f92672">-&gt;</span>ht[table].table[idx] <span style="color:#f92672">=</span> he<span style="color:#f92672">-&gt;</span>next;
                <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>nofree) {
                  	<span style="color:#75715e">//nofree传入的值为0，表示立马释放dictEntry以及其中key和value占用的内存
</span><span style="color:#75715e"></span>                    dictFreeKey(d, he);
                    dictFreeVal(d, he);
                    zfree(he);
                }
                d<span style="color:#f92672">-&gt;</span>ht[table].used<span style="color:#f92672">--</span>;
                <span style="color:#66d9ef">return</span> he;
            }
            prevHe <span style="color:#f92672">=</span> he;
            he <span style="color:#f92672">=</span> he<span style="color:#f92672">-&gt;</span>next;
        }
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dictIsRehashing(d)) <span style="color:#66d9ef">break</span>;
    }
    <span style="color:#66d9ef">return</span> NULL;
}
</code></pre></div><p>其中释放内存主要是三个方法dictFreeKey，dictFreeVal，zfree，前两个方法直接调用key和value的destructor，依次看看key和value的释放过程：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">define dictFreeKey(d, entry) 
    <span style="color:#66d9ef">if</span> ((d)<span style="color:#f92672">-&gt;</span>type<span style="color:#f92672">-&gt;</span>keyDestructor) 
        (d)<span style="color:#f92672">-&gt;</span>type<span style="color:#f92672">-&gt;</span>keyDestructor((d)<span style="color:#f92672">-&gt;</span>privdata, (entry)<span style="color:#f92672">-&gt;</span>key)

define dictFreeVal(d, entry) 
    <span style="color:#66d9ef">if</span> ((d)<span style="color:#f92672">-&gt;</span>type<span style="color:#f92672">-&gt;</span>valDestructor) 
        (d)<span style="color:#f92672">-&gt;</span>type<span style="color:#f92672">-&gt;</span>valDestructor((d)<span style="color:#f92672">-&gt;</span>privdata, (entry)<span style="color:#f92672">-&gt;</span>v.val)
</code></pre></div><p>在server.c中，可以找到对应的keyDestructor和valDestructor的原型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">dictType dbDictType <span style="color:#f92672">=</span> {
    dictSdsHash,               
    NULL,                       
    NULL,                       
    dictSdsKeyCompare,     
  	<span style="color:#75715e">//负责key的销毁
</span><span style="color:#75715e"></span>    dictSdsDestructor, 
  	<span style="color:#75715e">//负责value的销毁
</span><span style="color:#75715e"></span>    dictObjectDestructor  
};
</code></pre></div><p>可以看到，key的销毁实际上就是释放存储具体key值的sds：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dictSdsDestructor</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>privdata, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>val)
{
    DICT_NOTUSED(privdata);

    sdsfree(val);
}
</code></pre></div><p>但是对于value，就会存在比较多的类型：string、list、set、zset、hash&hellip;，根据redisobj中的type调用不同的free方法，同时value的删除依据就是引用计数法：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dictObjectDestructor</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>privdata, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>val)
{
    DICT_NOTUSED(privdata);

    <span style="color:#66d9ef">if</span> (val <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span>;
    decrRefCount(val);
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">decrRefCount</span>(robj <span style="color:#f92672">*</span>o) {
    <span style="color:#66d9ef">if</span> (o<span style="color:#f92672">-&gt;</span>refcount <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>) {
      	<span style="color:#75715e">//使用引用计数法作为依据进行删除
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">switch</span>(o<span style="color:#f92672">-&gt;</span>type) {
        <span style="color:#66d9ef">case</span> OBJ_STRING: freeStringObject(o); <span style="color:#66d9ef">break</span>;
        <span style="color:#66d9ef">case</span> OBJ_LIST: freeListObject(o); <span style="color:#66d9ef">break</span>;
        <span style="color:#66d9ef">case</span> OBJ_SET: freeSetObject(o); <span style="color:#66d9ef">break</span>;
        <span style="color:#66d9ef">case</span> OBJ_ZSET: freeZsetObject(o); <span style="color:#66d9ef">break</span>;
        <span style="color:#66d9ef">case</span> OBJ_HASH: freeHashObject(o); <span style="color:#66d9ef">break</span>;
        <span style="color:#66d9ef">case</span> OBJ_MODULE: freeModuleObject(o); <span style="color:#66d9ef">break</span>;
        <span style="color:#66d9ef">case</span> OBJ_STREAM: freeStreamObject(o); <span style="color:#66d9ef">break</span>;
        <span style="color:#66d9ef">default</span><span style="color:#f92672">:</span> serverPanic(<span style="color:#e6db74">&#34;Unknown object type&#34;</span>); <span style="color:#66d9ef">break</span>;
        }
        zfree(o);
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#66d9ef">if</span> (o<span style="color:#f92672">-&gt;</span>refcount <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) serverPanic(<span style="color:#e6db74">&#34;decrRefCount against refcount &lt;= 0&#34;</span>);
        <span style="color:#66d9ef">if</span> (o<span style="color:#f92672">-&gt;</span>refcount <span style="color:#f92672">!=</span> OBJ_SHARED_REFCOUNT) o<span style="color:#f92672">-&gt;</span>refcount<span style="color:#f92672">--</span>;
    }
}
</code></pre></div><p>不同的value类型有着不同的释放内存方法，但是它们都调用了zfree，接下来看看zfree的方法内部实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">zfree</span>(<span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr) {
  	<span style="color:#75715e">//ptr指针为void类型，可以指向任意数据类型的内存
</span><span style="color:#75715e"></span><span style="color:#75715e">#ifndef HAVE_MALLOC_SIZE
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>realptr;
    size_t oldsize;
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>		<span style="color:#75715e">//根据不同的宏定义，释放不同大小的内存，但是都调用了free方法
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (ptr <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span>;
<span style="color:#75715e">#ifdef HAVE_MALLOC_SIZE
</span><span style="color:#75715e"></span>    update_zmalloc_stat_free(zmalloc_size(ptr));
    free(ptr);
<span style="color:#75715e">#else
</span><span style="color:#75715e"></span>    realptr <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)ptr<span style="color:#f92672">-</span>PREFIX_SIZE;
    oldsize <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>((size_t<span style="color:#f92672">*</span>)realptr);
    update_zmalloc_stat_free(oldsize<span style="color:#f92672">+</span>PREFIX_SIZE);
    free(realptr);
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>}
</code></pre></div><p>底层调用了free接口，这属于操作系统提供的标准库函数，以我的macos为例，free函数存在于_malloc.h头文件定义中。一些linux系统可能会定义在stdlib标准库头文件中。</p>
]]></content>
        </item>
        
        <item>
            <title>Redis存储原理剖析&lt;一&gt;：存储模型和基础命令解析</title>
            <link>https://Huang-zh.github.io/posts/redis1/</link>
            <pubDate>Fri, 25 Aug 2023 22:10:44 +0800</pubDate>
            
            <guid>https://Huang-zh.github.io/posts/redis1/</guid>
            <description>1. 前言  2022年，是充满挑战性的一年。
这一年，我选择离开了自己熟悉的信息化领域，把精力投向了互联网金融。
在22年的后半程，鉴于平台和团队所带来的效应，个人也在高频交易业务领域吸收了足够多的知识。过程中，认知的颠覆和自我的怀疑常常是共存。
所幸这些经历最后都能够作为养分，支撑我一步步走到当下。
这个系列的文章，初稿实际上在22年的年底就已经完成。但碍于平日里事务繁忙兼琐事繁多，使得日子一再蹉跎，一直推迟到23年过半，才开始尝试去重新梳理其中的些许细节，并准备将它发表在博客里。
初稿原本诞生于22年在高频交易系统的技术选型、架构搭建和研发过程中。当时和团队里优秀的工程师们对redis尝试不断地深入探索，试图吸收其在架构设计方面的优点，并思考对于交易业务领域可以如何进行二次开发以达到发挥极致性能的目的，从而形成了这份初稿。当然，由于保密机制，文档中原先存在的定制化方案和敏感信息已去除，但对redis架构有兴趣的朋友，仍然可以通过这个系列洞悉redis在设计方面的优点。
过程中难免会因为篇幅原因删除细枝末节的代码，这也是为更好的去掌握主流程，让整个文档脉络更清晰而做的取舍。若对内容有异议，可通过邮箱联系我。
 huangzh 2023.08.25    阅读本文档存在一些门槛，不建议新手直接阅读，建议大家先掌握以下必要的技能：  良好的c语言基础。 掌握多路复用编程网络模型。 对操作系统中io的认知。 学习并调试过其他常用中间件代码的经验。 耐心。   redis的存储模型，是典型的hash存储。即一个key对应一个或多个值，这在redis支持的数据类型有着明确的体现，redis一共支持五种类型的数据结构存储：
 string hash（又称为set） list zset zlist  从广义上来看，这五种类型数据的存储都可以用key-value形式去实现，无非是value所对应的值的形式有所不同。
 2. hash存储引擎 提到redis，不得不先提及hash存储引擎的概念，一个典型的hash存储引擎原理如下图所示：
这种基于hash的存储方式，与传统关系性数据库有着非常大的区别。
在内存中通过一定的hash算法均匀的散列key值，使不同的key均匀的散落在hashtable的不同栏位。
由于相同的key可能对应不同的value，因此hashtable每个栏位实际上采用挂载链表的形式存储每一个value节点。
每个value节点中，包含三个最重要的元素：
 position：value的起始位置 size：value对应的长度 fileid：value存储的文件标识符  当然，节点中当然可以包含其他额外的值，不同软件有着自己的额外添加的元素。
但是，不约而外的，通过这三个必要的元素，可以找到key对应的value究竟存储于哪个文件，以及value在该文件中对应的起始位置和长度。
通过这种方式，实际上可以很方便的查找key-value元素。同时，这种方式将hashtable中每个栏位的写入由随机写（hash值随机）转变为顺序写（每个栏位的数据只需要顺序往该栏位对应的文件中添加即可，通过节点链表顺序连接），大大提高了写入的效率。
同时，使用hash存储引擎还存在以下特点：
 时间复杂度o(1)。 满足“=”，“IN”条件查询。 不支持范围查询，比如between关键字。 不支持order by关键字排序。   3. redis数据模型 我们在描述一种存储类型的中间件时，无论它是缓存类的存储，亦或是传统写入磁盘的关系性数据库存储，都存在它们各自最基础也是最核心的数据存储模型，这里我个人习惯把它叫做数据模型，基于数据模型才能实现上层复杂的结构存储。
redis的数据模型，可以把它看成字典，一种基于key-value存储的数据结构，底层由数组实现的基于hashtable的拉链法存储。
以下是从redis源码中提取的四种以此从外到内的核心数据模型，其中redisDb为最外层，抽丝剥茧之后，不难发现真正的数据存储于底层的dictEntry：
typedef struct redisDb { dict *dict; /* The keyspace for this DB */ dict *expires; /* Timeout of keys with a timeout set */ dict *blocking_keys; /* Keys with clients waiting for data (BLPOP)*/ dict *ready_keys; /* Blocked keys that received a PUSH */ dict *watched_keys; /* WATCHED keys for MULTI/EXEC CAS */ int id; /* Database ID */ long long avg_ttl; /* Average TTL, just for stats */ list *defrag_later; /* List of key names to attempt to defrag one by one, gradually.</description>
            <content type="html"><![CDATA[<h3 id="1-前言">1. 前言</h3>
<blockquote>
<p>2022年，是充满挑战性的一年。</p>
<p>这一年，我选择离开了自己熟悉的信息化领域，把精力投向了互联网金融。</p>
<p>在22年的后半程，鉴于平台和团队所带来的效应，个人也在高频交易业务领域吸收了足够多的知识。过程中，认知的颠覆和自我的怀疑常常是共存。</p>
<p>所幸这些经历最后都能够作为养分，支撑我一步步走到当下。</p>
<p>这个系列的文章，初稿实际上在22年的年底就已经完成。但碍于平日里事务繁忙兼琐事繁多，使得日子一再蹉跎，一直推迟到23年过半，才开始尝试去重新梳理其中的些许细节，并准备将它发表在博客里。</p>
<p>初稿原本诞生于22年在高频交易系统的技术选型、架构搭建和研发过程中。当时和团队里优秀的工程师们对redis尝试不断地深入探索，试图吸收其在架构设计方面的优点，并思考对于交易业务领域可以如何进行二次开发以达到发挥极致性能的目的，从而形成了这份初稿。当然，由于保密机制，文档中原先存在的定制化方案和敏感信息已去除，但对redis架构有兴趣的朋友，仍然可以通过这个系列洞悉redis在设计方面的优点。</p>
<p>过程中难免会因为篇幅原因删除细枝末节的代码，这也是为更好的去掌握主流程，让整个文档脉络更清晰而做的取舍。若对内容有异议，可通过邮箱联系我。</p>
<pre><code>                                        huangzh
                                        2023.08.25
</code></pre>
</blockquote>
<hr>
<h4 id="阅读本文档存在一些门槛不建议新手直接阅读建议大家先掌握以下必要的技能">阅读本文档存在一些门槛，不建议新手直接阅读，建议大家先掌握以下必要的技能：</h4>
<ul>
<li>良好的c语言基础。</li>
<li>掌握多路复用编程网络模型。</li>
<li>对操作系统中io的认知。</li>
<li>学习并调试过其他常用中间件代码的经验。</li>
<li>耐心。</li>
</ul>
<hr>
<p>redis的存储模型，是典型的hash存储。即一个key对应一个或多个值，这在redis支持的数据类型有着明确的体现，redis一共支持五种类型的数据结构存储：</p>
<ul>
<li>string</li>
<li>hash（又称为set）</li>
<li>list</li>
<li>zset</li>
<li>zlist</li>
</ul>
<p>从广义上来看，这五种类型数据的存储都可以用key-value形式去实现，无非是value所对应的值的形式有所不同。</p>
<hr>
<h3 id="2-hash存储引擎">2. hash存储引擎</h3>
<p>提到redis，不得不先提及hash存储引擎的概念，一个典型的hash存储引擎原理如下图所示：</p>
<p><img src="https://qiniu.lemonhuang.com/hash.png" alt="hash存储示意"></p>
<p>这种基于hash的存储方式，与传统关系性数据库有着非常大的区别。</p>
<p>在内存中通过一定的hash算法均匀的散列key值，使不同的key均匀的散落在hashtable的不同栏位。</p>
<p>由于相同的key可能对应不同的value，因此hashtable每个栏位实际上采用挂载链表的形式存储每一个value节点。</p>
<p>每个value节点中，包含三个最重要的元素：</p>
<ul>
<li>position：value的起始位置</li>
<li>size：value对应的长度</li>
<li>fileid：value存储的文件标识符</li>
</ul>
<p>当然，节点中当然可以包含其他额外的值，不同软件有着自己的额外添加的元素。</p>
<p>但是，不约而外的，通过这三个必要的元素，可以找到key对应的value究竟存储于哪个文件，以及value在该文件中对应的起始位置和长度。</p>
<p>通过这种方式，实际上可以很方便的查找key-value元素。同时，这种方式将hashtable中每个栏位的写入由随机写（hash值随机）转变为顺序写（每个栏位的数据只需要顺序往该栏位对应的文件中添加即可，通过节点链表顺序连接），大大提高了写入的效率。</p>
<p>同时，使用hash存储引擎还存在以下特点：</p>
<ul>
<li>时间复杂度o(1)。</li>
<li>满足“=”，“IN”条件查询。</li>
<li>不支持范围查询，比如between关键字。</li>
<li>不支持order by关键字排序。</li>
</ul>
<hr>
<h3 id="3-redis数据模型">3. redis数据模型</h3>
<p>我们在描述一种存储类型的中间件时，无论它是缓存类的存储，亦或是传统写入磁盘的关系性数据库存储，都存在它们各自最基础也是最核心的数据存储模型，这里我个人习惯把它叫做数据模型，基于数据模型才能实现上层复杂的结构存储。</p>
<p>redis的数据模型，可以把它看成字典，一种基于key-value存储的数据结构，底层由数组实现的基于hashtable的拉链法存储。</p>
<p>以下是从redis源码中提取的四种以此从外到内的核心数据模型，其中redisDb为最外层，抽丝剥茧之后，不难发现真正的数据存储于底层的dictEntry：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> redisDb {
    dict <span style="color:#f92672">*</span>dict;                 <span style="color:#75715e">/* The keyspace for this DB */</span>
    dict <span style="color:#f92672">*</span>expires;              <span style="color:#75715e">/* Timeout of keys with a timeout set */</span>
    dict <span style="color:#f92672">*</span>blocking_keys;        <span style="color:#75715e">/* Keys with clients waiting for data (BLPOP)*/</span>
    dict <span style="color:#f92672">*</span>ready_keys;           <span style="color:#75715e">/* Blocked keys that received a PUSH */</span>
    dict <span style="color:#f92672">*</span>watched_keys;         <span style="color:#75715e">/* WATCHED keys for MULTI/EXEC CAS */</span>
    <span style="color:#66d9ef">int</span> id;                     <span style="color:#75715e">/* Database ID */</span>
    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> avg_ttl;          <span style="color:#75715e">/* Average TTL, just for stats */</span>
    list <span style="color:#f92672">*</span>defrag_later;         <span style="color:#75715e">/* List of key names to attempt to defrag one by one, gradually. */</span>
} redisDb;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> dict {
    dictType <span style="color:#f92672">*</span>type;
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>privdata;
    dictht ht[<span style="color:#ae81ff">2</span>];
    <span style="color:#66d9ef">long</span> rehashidx; <span style="color:#75715e">/* rehashing not in progress if rehashidx == -1 */</span>
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> iterators; <span style="color:#75715e">/* number of iterators currently running */</span>
} dict;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> dictht {
    dictEntry <span style="color:#f92672">**</span>table;
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> size;
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> sizemask;
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> used;
} dictht;

<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> dictEntry {
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key;
    <span style="color:#66d9ef">union</span> {
        <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>val;
        <span style="color:#66d9ef">uint64_t</span> u64;
        <span style="color:#66d9ef">int64_t</span> s64;
        <span style="color:#66d9ef">double</span> d;
    } v;
    <span style="color:#66d9ef">struct</span> dictEntry <span style="color:#f92672">*</span>next;
} dictEntry;
</code></pre></div><p>dictEntry是最基本的存储单元，包含了一组key-value元素，key即存储对应的key值，v所对应的union结构存储具体类型对应的value。还有一个next指针指向下一个存储单元，这样就可以构成一个链表。</p>
<p>dictht（全称dicthashtable）包含多条由dictEntry构成的链表，table作为二级指针，表示一组dictEntry，其中每一个dictEntry存储的值是指向具体存储了某个数据的dictEntry的指针，size标识有几条链表存在，used表示所有链表的节点总数。</p>
<p>dict再封装了两个dictht，一个用于存储真实的key-value数据（datatable），一个用于渐进式hash时临时存放原有的数据，我们的redis客户端指令每次对key的查找请求都是去datatable获取数据。</p>
<p>redisDb封装了dict，此外还有带有expire key的字典，即expires，可以理解为expires内部，用hash存储的方式存储了key对应的过期时间戳。</p>
<hr>
<h3 id="4-命令代码执行过程分析">4. 命令代码执行过程分析</h3>
<p>我们从两个最基本的redis命令案例分析源代码，实际上，这个过程不可能面面俱到，但是只要掌握大体的流程，就可以逐步洞悉内部的精髓。</p>
<h4 id="41-expire-key-expire">4.1 expire key expire</h4>
<p>来看一个最基本的命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">expire testKey 60
</code></pre></div><p>这个命令表示对值为testKey的key，设置60毫秒的过期时间。来看redis代码中对于该命令的处理：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#960050;background-color:#1e0010">ç</span>(client <span style="color:#f92672">*</span>c, redisDb <span style="color:#f92672">*</span>db, robj <span style="color:#f92672">*</span>key, <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span> when) {
    dictEntry <span style="color:#f92672">*</span>kde, <span style="color:#f92672">*</span>de;

    <span style="color:#75715e">// 1.先从redisDb中的dict中获取存储了key-value的dictEntry，由kde指针指向该dictEntry的地址
</span><span style="color:#75715e"></span>    kde <span style="color:#f92672">=</span> dictFind(db<span style="color:#f92672">-&gt;</span>dict,key<span style="color:#f92672">-&gt;</span>ptr);
    serverAssertWithInfo(NULL,key,kde <span style="color:#f92672">!=</span> NULL);
  	<span style="color:#75715e">// 2.从redisDb中的expire字典中寻找存储了具体过期时间戳的dictEntry，由de指针指向该dictEntry的地址
</span><span style="color:#75715e"></span>    de <span style="color:#f92672">=</span> dictAddOrFind(db<span style="color:#f92672">-&gt;</span>expires,dictGetKey(kde));
  	<span style="color:#75715e">// 3.更新de所指向的dictEntry中的过期时间
</span><span style="color:#75715e"></span>    dictSetSignedIntegerVal(de,when);
		<span style="color:#75715e">// 4.触发集群间的同步，保证数据一致性
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> writable_slave <span style="color:#f92672">=</span> server.masterhost <span style="color:#f92672">&amp;&amp;</span> server.repl_slave_ro <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">if</span> (c <span style="color:#f92672">&amp;&amp;</span> writable_slave <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>(c<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> CLIENT_MASTER))
        rememberSlaveKeyWithExpire(db,key);
}
</code></pre></div><p>这里为什么要先从具体存储数据的字典中先查找一遍？个人认为是为了保证数据必须真实存储在字典中，因为redis的过期机制（惰性/LFU/LRU）往往需要cpu花费一些时间片去调度，所以在设计上需要尽可能严格的保证资源的不必要浪费。</p>
<p>dictFind是最基础的查询函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">dictEntry <span style="color:#f92672">*</span><span style="color:#a6e22e">dictFind</span>(dict <span style="color:#f92672">*</span>d, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key)
{
    dictEntry <span style="color:#f92672">*</span>he;
    <span style="color:#66d9ef">uint64_t</span> h, idx, table;
		<span style="color:#75715e">// 1.如果两个dictht的used均为0，说明当前既没有数据存储，也没有发生扩容导致的rehash，直接返回NUll。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].used <span style="color:#f92672">+</span> d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">1</span>].used <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> NULL; 
  	<span style="color:#75715e">// 2.如果当前正在发生扩容，则当前线程帮助推进rehash的过程
</span><span style="color:#75715e"></span>  	<span style="color:#75715e">//   这样做的目的，是将rehash的压力分担到各个操作中去（修改/删除/查询）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (dictIsRehashing(d)) _dictRehashStep(d);
  	<span style="color:#75715e">// 3.得到key的hash值
</span><span style="color:#75715e"></span>    h <span style="color:#f92672">=</span> dictHashKey(d, key);
  	<span style="color:#75715e">// 4.hash值模上hashtable的使用栏位数量，得到一个由dictEntry构成的链表
</span><span style="color:#75715e"></span>  	<span style="color:#75715e">//   依次遍历每一个dictEntry，比较key的值，得到最终的entry
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (table <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; table <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>; table<span style="color:#f92672">++</span>) {
        idx <span style="color:#f92672">=</span> h <span style="color:#f92672">&amp;</span> d<span style="color:#f92672">-&gt;</span>ht[table].sizemask;
        he <span style="color:#f92672">=</span> d<span style="color:#f92672">-&gt;</span>ht[table].table[idx];
        <span style="color:#66d9ef">while</span>(he) {
            <span style="color:#66d9ef">if</span> (key<span style="color:#f92672">==</span>he<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">||</span> dictCompareKeys(d, key, he<span style="color:#f92672">-&gt;</span>key))
                <span style="color:#66d9ef">return</span> he;
            he <span style="color:#f92672">=</span> he<span style="color:#f92672">-&gt;</span>next;
        }
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dictIsRehashing(d)) <span style="color:#66d9ef">return</span> NULL;
    }
    <span style="color:#66d9ef">return</span> NULL;
}
</code></pre></div><p>接下来看看dictAddOrFind，这个方法对key进行查找，如果不存在会新增，否则得到原本就存在的dictEntry。是否符合我们expire命令的逻辑？原先testKey不存在expireTime，我们通过命令设置expireTime的过程就是在expire字典中新增一个dictEntry，然后设置它的value为expireTime对应的时间戳：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">dictEntry <span style="color:#f92672">*</span><span style="color:#a6e22e">dictAddOrFind</span>(dict <span style="color:#f92672">*</span>d, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key) {
    dictEntry <span style="color:#f92672">*</span>entry, <span style="color:#f92672">*</span>existing;
    entry <span style="color:#f92672">=</span> dictAddRaw(d,key,<span style="color:#f92672">&amp;</span>existing);
  	<span style="color:#75715e">//如果entry指针的值存在，说明entry指针指向的dictEntry是通过dictAddRaw新增的，否则返回原本存在的existing地址。
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> entry <span style="color:#f92672">?</span> entry : existing;
}

dictEntry <span style="color:#f92672">*</span><span style="color:#a6e22e">dictAddRaw</span>(dict <span style="color:#f92672">*</span>d, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key, dictEntry <span style="color:#f92672">**</span>existing)
{
    <span style="color:#66d9ef">long</span> index;
    dictEntry <span style="color:#f92672">*</span>entry;
    dictht <span style="color:#f92672">*</span>ht;
		<span style="color:#75715e">// 1.如果当前正在发生扩容，则当前线程帮助推进rehash的过程
</span><span style="color:#75715e"></span>  	<span style="color:#75715e">//   这样做的目的，是将rehash的压力分担到各个操作中去（修改/删除/查询）
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (dictIsRehashing(d)) _dictRehashStep(d);

    <span style="color:#75715e">// 2.如果计算出index为-1，代表原先存在，返回null
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ((index <span style="color:#f92672">=</span> _dictKeyIndex(d, key, dictHashKey(d,key), existing)) <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
        <span style="color:#66d9ef">return</span> NULL;

    <span style="color:#75715e">// 3.1 原先不存在，判断是否处于rehash状态，如果是就将数据存储于第二个hashtable，否则存储于第一个hashtable
</span><span style="color:#75715e"></span>  	ht <span style="color:#f92672">=</span> dictIsRehashing(d) <span style="color:#f92672">?</span> <span style="color:#f92672">&amp;</span>d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">:</span> <span style="color:#f92672">&amp;</span>d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>];
    <span style="color:#75715e">// 3.2 分配需要的内存，将新的dictEntry插入链表的头部
</span><span style="color:#75715e"></span>    entry <span style="color:#f92672">=</span> zmalloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>entry));
    entry<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> ht<span style="color:#f92672">-&gt;</span>table[index];
    ht<span style="color:#f92672">-&gt;</span>table[index] <span style="color:#f92672">=</span> entry;
    ht<span style="color:#f92672">-&gt;</span>used<span style="color:#f92672">++</span>;

    <span style="color:#75715e">// 4.为新的dictEntry设置key值
</span><span style="color:#75715e"></span>    dictSetKey(d, entry, key);
    <span style="color:#66d9ef">return</span> entry;
}
</code></pre></div><p>如果觉得不够清晰，可以看一下dictFind的调用时序图：</p>

<script async type="application/javascript" src="https://cdn.jsdelivr.net/npm/mermaid@9.1.1/dist/mermaid.min.js">
    var config = {
      startOnLoad:true,
      theme:'neutral',
      align:'left'
    };
    mermaid.initialize(config);
  </script>
  
  <div class="mermaid">
    
   sequenceDiagram
　　participant dictAddOrFind
　　participant dictAddRaw
　　dictAddOrFind->>dictAddRaw:invoke
　　
　　Note OVER		dictAddRaw: 判断是否触发_dictRehashStep推进rehash
　　Note OVER		dictAddRaw: 计算index，判断是否已存在entry，存在直接返回NULL
　　Note OVER		dictAddRaw: 判断是否处于rehash过程，决定存储于哪个hashtable
　　Note OVER		dictAddRaw: 分配内存，构造dictEntry，插入链表头部
　　Note OVER		dictAddRaw: 为新的dictEntry设置key值
　　
　　dictAddRaw-->>dictAddOrFind:return
　　Note OVER		dictAddOrFind: 已存在返回&existing，否则返回dictEntry *entry

  </div>

<hr>
<h4 id="42-set-key-value">4.2 set key value</h4>
<p>再来看一个命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">set name huangzh
</code></pre></div><p>这是最基本的添加数据命令，表示我们可以使用该命令创造一个key为name，value为huangzh的dictEntry。那么，从这个命令进入redis-server端的代码，看看它的执行流程：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setKey</span>(redisDb <span style="color:#f92672">*</span>db, robj <span style="color:#f92672">*</span>key, robj <span style="color:#f92672">*</span>val) {
  	<span style="color:#75715e">// 1.lookupKeyWrite查找字典中是否存在key，内部实际上仍然调用dictFind基础查询函数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (lookupKeyWrite(db,key) <span style="color:#f92672">==</span> NULL) {
      	<span style="color:#75715e">// 2.如果当前key在字典中不存在，新增
</span><span style="color:#75715e"></span>        dbAdd(db,key,val);
    } <span style="color:#66d9ef">else</span> {
      	<span style="color:#75715e">// 3.如果当前key在字典中存在，覆盖
</span><span style="color:#75715e"></span>        dbOverwrite(db,key,val);
    }
  	<span style="color:#75715e">// 4.value的引用计数+1
</span><span style="color:#75715e"></span>    incrRefCount(val);
  	<span style="color:#75715e">// 5.如果原先db中存在key且配置了expireTime，这一步会直接移除存储old key过期时间的dictEntry
</span><span style="color:#75715e"></span>    removeExpire(db,key);
  	<span style="color:#75715e">// 6.通知watch了该key的客户端
</span><span style="color:#75715e"></span>    signalModifiedKey(db,key);
}
</code></pre></div><p>这里我们看到了新的类型robj，它的全称是redisObject，事实上，在dictEntry中，存储的key和value时的传参都是用它作为载体：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> redisObject {
  	<span style="color:#75715e">// 类型，枚举值，对应了redis支持的所有数据类型
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> type:<span style="color:#ae81ff">4</span>;
  	<span style="color:#75715e">// 编码
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> encoding:<span style="color:#ae81ff">4</span>;
  	<span style="color:#75715e">// 24位存储，用于LRU或是LFU淘汰机制，在后面会专门描述
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">unsigned</span> lru:LRU_BITS; 
  	<span style="color:#75715e">// 当前引用数
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> refcount;
  	<span style="color:#75715e">// 指向具体值的指针
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr;
} robj;
</code></pre></div><p>回到setKey的主流程，上面说到，如果当前字典不存在key，则调用dbAdd函数进行新增，我们从这里进入内部的实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">dbAdd</span>(redisDb <span style="color:#f92672">*</span>db, robj <span style="color:#f92672">*</span>key, robj <span style="color:#f92672">*</span>val) {
  	<span style="color:#75715e">//sds 全称Simple Dynamic Strings，是redis中提供的简易安全的字符串库
</span><span style="color:#75715e"></span>    sds copy <span style="color:#f92672">=</span> sdsdup(key<span style="color:#f92672">-&gt;</span>ptr);
  	<span style="color:#75715e">// 调用字典的新增方法
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> retval <span style="color:#f92672">=</span> dictAdd(db<span style="color:#f92672">-&gt;</span>dict, copy, val);

    serverAssertWithInfo(NULL,key,retval <span style="color:#f92672">==</span> DICT_OK);
    <span style="color:#66d9ef">if</span> (val<span style="color:#f92672">-&gt;</span>type <span style="color:#f92672">==</span> OBJ_LIST <span style="color:#f92672">||</span>
        val<span style="color:#f92672">-&gt;</span>type <span style="color:#f92672">==</span> OBJ_ZSET)
        signalKeyAsReady(db, key);
    <span style="color:#66d9ef">if</span> (server.cluster_enabled) slotToKeyAdd(key);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dictAdd</span>(dict <span style="color:#f92672">*</span>d, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>val)
{		
  	<span style="color:#75715e">//实际新增在这一步，dictAddRaw已经分析过，不做赘述
</span><span style="color:#75715e"></span>    dictEntry <span style="color:#f92672">*</span>entry <span style="color:#f92672">=</span> dictAddRaw(d,key,NULL);

    <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>entry) <span style="color:#66d9ef">return</span> DICT_ERR;
  	<span style="color:#75715e">//为新增的dictEntry填充value
</span><span style="color:#75715e"></span>    dictSetVal(d, entry, val);
    <span style="color:#66d9ef">return</span> DICT_OK;
}
</code></pre></div><p>这里出现了一个结构体叫做sds，全称Simple Dynamic Strings，是redis提供的字符串高效操作库，不是分析的重点，具体可参考https://github.com/antirez/sds。</p>
<p>可以看到实际调用dictAddRaw函数进行新增的时候，传入的是sds，而在之前已经分析过，dictAddRaw会对新增的dictEntry进行key的填充，所以我们可以得出，其实sds才是key作为存储的数据载体，那么来看一下构造sds的过程：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">sds <span style="color:#a6e22e">sdsdup</span>(<span style="color:#66d9ef">const</span> sds s) {
    <span style="color:#66d9ef">return</span> sdsnewlen(s, sdslen(s));
}

sds <span style="color:#a6e22e">sdsnewlen</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>init, size_t initlen) {
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>sh;
    sds s;
  	<span style="color:#75715e">// 根据初始字符串决定构造的动态字符串类型
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> type <span style="color:#f92672">=</span> sdsReqType(initlen);
    <span style="color:#75715e">// 空串判断
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (type <span style="color:#f92672">==</span> SDS_TYPE_5 <span style="color:#f92672">&amp;&amp;</span> initlen <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) type <span style="color:#f92672">=</span> SDS_TYPE_8;
    <span style="color:#66d9ef">int</span> hdrlen <span style="color:#f92672">=</span> sdsHdrSize(type);
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>fp;

    assert(hdrlen<span style="color:#f92672">+</span>initlen<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;</span> initlen); 
  	<span style="color:#75715e">//分配需要的内存，sds的结构：header的长度+字符串值的初始长度+末尾的空项长度
</span><span style="color:#75715e"></span>    sh <span style="color:#f92672">=</span> s_malloc(hdrlen<span style="color:#f92672">+</span>initlen<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">if</span> (init<span style="color:#f92672">==</span>SDS_NOINIT)
        init <span style="color:#f92672">=</span> NULL;
    <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>init)
        memset(sh, <span style="color:#ae81ff">0</span>, hdrlen<span style="color:#f92672">+</span>initlen<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">if</span> (sh <span style="color:#f92672">==</span> NULL) <span style="color:#66d9ef">return</span> NULL;
    s <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)sh<span style="color:#f92672">+</span>hdrlen;
  	<span style="color:#75715e">//fp是返回用于读取的实际指针，指向header末尾
</span><span style="color:#75715e"></span>    fp <span style="color:#f92672">=</span> ((<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span>)s)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
  	<span style="color:#75715e">//根据不同的类型，构造实际的动态字符串
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">switch</span>(type) {
        <span style="color:#66d9ef">case</span> SDS_TYPE_5: {
            <span style="color:#f92672">*</span>fp <span style="color:#f92672">=</span> type <span style="color:#f92672">|</span> (initlen <span style="color:#f92672">&lt;&lt;</span> SDS_TYPE_BITS);
            <span style="color:#66d9ef">break</span>;
        }
        <span style="color:#66d9ef">case</span> SDS_TYPE_8: {
            SDS_HDR_VAR(<span style="color:#ae81ff">8</span>,s);
            sh<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">=</span> initlen;
            sh<span style="color:#f92672">-&gt;</span>alloc <span style="color:#f92672">=</span> initlen;
            <span style="color:#f92672">*</span>fp <span style="color:#f92672">=</span> type;
            <span style="color:#66d9ef">break</span>;
        }
        <span style="color:#66d9ef">case</span> SDS_TYPE_16: {
            SDS_HDR_VAR(<span style="color:#ae81ff">16</span>,s);
            sh<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">=</span> initlen;
            sh<span style="color:#f92672">-&gt;</span>alloc <span style="color:#f92672">=</span> initlen;
            <span style="color:#f92672">*</span>fp <span style="color:#f92672">=</span> type;
            <span style="color:#66d9ef">break</span>;
        }
        <span style="color:#66d9ef">case</span> SDS_TYPE_32: {
            SDS_HDR_VAR(<span style="color:#ae81ff">32</span>,s);
            sh<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">=</span> initlen;
            sh<span style="color:#f92672">-&gt;</span>alloc <span style="color:#f92672">=</span> initlen;
            <span style="color:#f92672">*</span>fp <span style="color:#f92672">=</span> type;
            <span style="color:#66d9ef">break</span>;
        }
        <span style="color:#66d9ef">case</span> SDS_TYPE_64: {
            SDS_HDR_VAR(<span style="color:#ae81ff">64</span>,s);
            sh<span style="color:#f92672">-&gt;</span>len <span style="color:#f92672">=</span> initlen;
            sh<span style="color:#f92672">-&gt;</span>alloc <span style="color:#f92672">=</span> initlen;
            <span style="color:#f92672">*</span>fp <span style="color:#f92672">=</span> type;
            <span style="color:#66d9ef">break</span>;
        }
    }
    <span style="color:#66d9ef">if</span> (initlen <span style="color:#f92672">&amp;&amp;</span> init)
      	<span style="color:#75715e">//拷贝字符串的值到新构造的动态字符串
</span><span style="color:#75715e"></span>        memcpy(s, init, initlen);
  	<span style="color:#75715e">//末尾空项补齐
</span><span style="color:#75715e"></span>    s[initlen] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;\0&#39;</span>;
    <span style="color:#66d9ef">return</span> s;
}
</code></pre></div><p>最后来看一下不同type对应的动态字符串内部结构，可以看到它们都包含了表示长度的len和存储实际字符的数组buf，sdshdr5比较特殊，因为定位其为空串，所以不需要记录长度：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__attribute__</span> ((__packed__)) sdshdr5 {
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> flags; 
    <span style="color:#66d9ef">char</span> buf[];
};
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__attribute__</span> ((__packed__)) sdshdr8 {
    <span style="color:#66d9ef">uint8_t</span> len; 
    <span style="color:#66d9ef">uint8_t</span> alloc; 
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> flags; 
    <span style="color:#66d9ef">char</span> buf[];
};
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__attribute__</span> ((__packed__)) sdshdr16 {
    <span style="color:#66d9ef">uint16_t</span> len; 
    <span style="color:#66d9ef">uint16_t</span> alloc; 
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> flags; 
    <span style="color:#66d9ef">char</span> buf[];
};
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__attribute__</span> ((__packed__)) sdshdr32 {
    <span style="color:#66d9ef">uint32_t</span> len; 
    <span style="color:#66d9ef">uint32_t</span> alloc; 
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> flags;
    <span style="color:#66d9ef">char</span> buf[];
};
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__attribute__</span> ((__packed__)) sdshdr64 {
    <span style="color:#66d9ef">uint64_t</span> len; 
    <span style="color:#66d9ef">uint64_t</span> alloc; 
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> flags; 
    <span style="color:#66d9ef">char</span> buf[];
};
</code></pre></div><p>接着再回到setKey的主流程，看看removeExpire的内部逻辑：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">removeExpire</span>(redisDb <span style="color:#f92672">*</span>db, robj <span style="color:#f92672">*</span>key) {
    serverAssertWithInfo(NULL,key,dictFind(db<span style="color:#f92672">-&gt;</span>dict,key<span style="color:#f92672">-&gt;</span>ptr) <span style="color:#f92672">!=</span> NULL);
  	<span style="color:#75715e">//从db中的exipre字典删除key对应的dictEntry
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> dictDelete(db<span style="color:#f92672">-&gt;</span>expires,key<span style="color:#f92672">-&gt;</span>ptr) <span style="color:#f92672">==</span> DICT_OK;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">dictDelete</span>(dict <span style="color:#f92672">*</span>ht, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key) {
    <span style="color:#66d9ef">return</span> dictGenericDelete(ht,key,<span style="color:#ae81ff">0</span>) <span style="color:#f92672">?</span> DICT_OK : DICT_ERR;
}

<span style="color:#66d9ef">static</span> dictEntry <span style="color:#f92672">*</span><span style="color:#a6e22e">dictGenericDelete</span>(dict <span style="color:#f92672">*</span>d, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key, <span style="color:#66d9ef">int</span> nofree) {
    <span style="color:#66d9ef">uint64_t</span> h, idx;
    dictEntry <span style="color:#f92672">*</span>he, <span style="color:#f92672">*</span>prevHe;
    <span style="color:#66d9ef">int</span> table;
		<span style="color:#75715e">//当前没有数据存储，直接返回NULL
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">0</span>].used <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">&amp;&amp;</span> d<span style="color:#f92672">-&gt;</span>ht[<span style="color:#ae81ff">1</span>].used <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> NULL;
		<span style="color:#75715e">//如果当前正在rehash，则触发推进rehash的过程
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> (dictIsRehashing(d)) _dictRehashStep(d);
  	<span style="color:#75715e">//计算hash值
</span><span style="color:#75715e"></span>    h <span style="color:#f92672">=</span> dictHashKey(d, key);
		
  	<span style="color:#75715e">//遍历两个hashtable，找到链表中符合key值的dictEntry
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (table <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; table <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">1</span>; table<span style="color:#f92672">++</span>) {
        idx <span style="color:#f92672">=</span> h <span style="color:#f92672">&amp;</span> d<span style="color:#f92672">-&gt;</span>ht[table].sizemask;
        he <span style="color:#f92672">=</span> d<span style="color:#f92672">-&gt;</span>ht[table].table[idx];
        prevHe <span style="color:#f92672">=</span> NULL;
        <span style="color:#66d9ef">while</span>(he) {
            <span style="color:#66d9ef">if</span> (key<span style="color:#f92672">==</span>he<span style="color:#f92672">-&gt;</span>key <span style="color:#f92672">||</span> dictCompareKeys(d, key, he<span style="color:#f92672">-&gt;</span>key)) {
                <span style="color:#66d9ef">if</span> (prevHe)
                  	<span style="color:#75715e">//当前节点的前继节点的下一个节点指针直接指向当前节点的后继节点
</span><span style="color:#75715e"></span>                    prevHe<span style="color:#f92672">-&gt;</span>next <span style="color:#f92672">=</span> he<span style="color:#f92672">-&gt;</span>next;
                <span style="color:#66d9ef">else</span>
                  	<span style="color:#75715e">//如果是头节点，则头节点指针改为当前节点的后继节点
</span><span style="color:#75715e"></span>                    d<span style="color:#f92672">-&gt;</span>ht[table].table[idx] <span style="color:#f92672">=</span> he<span style="color:#f92672">-&gt;</span>next;
                <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>nofree) {
                  	<span style="color:#75715e">//释放内存
</span><span style="color:#75715e"></span>                    dictFreeKey(d, he);
                    dictFreeVal(d, he);
                    zfree(he);
                }
              	<span style="color:#75715e">//hashtable的节点使用数-1
</span><span style="color:#75715e"></span>                d<span style="color:#f92672">-&gt;</span>ht[table].used<span style="color:#f92672">--</span>;
                <span style="color:#66d9ef">return</span> he;
            }
            prevHe <span style="color:#f92672">=</span> he;
            he <span style="color:#f92672">=</span> he<span style="color:#f92672">-&gt;</span>next;
        }
        <span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>dictIsRehashing(d)) <span style="color:#66d9ef">break</span>;
    }
  	<span style="color:#75715e">//如果没命中key，则返回NULL
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> NULL; 
}
</code></pre></div><p>那么，来画一个简单的setKey函数执行add key命令时的时序图，省略集群同步和监听通知等步骤后如下：

<script async type="application/javascript" src="https://cdn.jsdelivr.net/npm/mermaid@9.1.1/dist/mermaid.min.js">
    var config = {
      startOnLoad:true,
      theme:'neutral',
      align:'left'
    };
    mermaid.initialize(config);
  </script>
  
  <div class="mermaid">
    
  sequenceDiagram
　　participant setKey
　　participant lookupKeyWrite
　　participant dictFind
　	 participant dbAdd
　	 participant dictAdd
　　setKey->>lookupKeyWrite:invoke
　　
　　lookupKeyWrite->>dictFind:invoke
　　dictFind-->>lookupKeyWrite:return
　　
　　lookupKeyWrite-->>setKey:return
　　Note OVER setKey: 判断dictEntry是否存在，不存在就调用dbAdd新增
		setKey->>dbAdd:invoke
		Note OVER	dbAdd: 创建sds，装载redisObject中的ptr值
		dbAdd->>dictAdd:invoke
		Note OVER dictAdd: 调用dictAddRaw，创建dictEntry，存入hashtable并填充key值
		Note OVER dictAdd: 调用dictSetVal填充value
		dictAdd-->>dbAdd:return
		dbAdd-->>setKey:return
		Note OVER setKey: 调用incrRefCount使value引用计数+1
		Note OVER setKey: 调用removeExpire重置expire过期时间

  </div>
</p>
<p>比起一层层深入的跟踪源码，这种时序图能更直观的反应代码执行时的主体流程，也更考验对代码整体逻辑的总结归纳能力。</p>
<p>至此，通过两个简单案例的分析，由浅入深，可以洞悉redis在存储数据时其字典数据结构的全貌：</p>
<p><img src="https://qiniu.lemonhuang.com/Untitled%20Diagram.drawio%20%281%29.png" alt="redis存储数据模型"></p>
<hr>
<h3 id="5-key对内存的影响">5. Key对内存的影响</h3>
<p>实际上，在redis中，一个key往往需要存储在两个hashtable中，一个是存储data的ht，而另一份则是存储了过期时间戳的ht。也就意味着，如果为一个key设置了expireTime，那么在redis会存在两份key，这使得在一些极端情况不得不考虑key的大小对内存占用的影响。</p>
<p>通过上面的分析，已经知道真正存储key的是sds结构体，但是在转化sds之前，需要先经过dictEntry和redisObject的过渡，也就意味着创建dictEntry和redisObject的内存全部都要计入key的存储范围。</p>
<p>我们以64位编译器为例子，先看redisObject的结构：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> redisObject {
    <span style="color:#66d9ef">unsigned</span> type:<span style="color:#ae81ff">4</span>;
    <span style="color:#66d9ef">unsigned</span> encoding:<span style="color:#ae81ff">4</span>;
    <span style="color:#66d9ef">unsigned</span> lru:LRU_BITS; 
    <span style="color:#66d9ef">int</span> refcount;
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>ptr;
} robj;
</code></pre></div><p>64位编译器的void指针占用8个字节，int类型占用4个字节。LRU_BITS为24，即24位3个字节。type4位，encoding4位，合计一个字节。所以构成一个redisObject需要16个字节的容量。</p>
<p>再看dictEntry：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> dictEntry {
    <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>key;
    <span style="color:#66d9ef">union</span> {
        <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>val;
        <span style="color:#66d9ef">uint64_t</span> u64;
        <span style="color:#66d9ef">int64_t</span> s64;
        <span style="color:#66d9ef">double</span> d;
    } v;
    <span style="color:#66d9ef">struct</span> dictEntry <span style="color:#f92672">*</span>next;
} dictEntry;
</code></pre></div><p>针对64位编译器void指针还是8个字节，union里所有的类型均占用8个字节，next为结构体指针，因此在64位编译器中也占用8个字节，因此构成一个dictEntry需要24个字节的容量。</p>
<p>最后我们看sds，这里我们使用上面值为testKey作为例子，首先testKey字符串的长度为七个字节，会被分配到的sds类型结构如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">__attribute__</span> ((__packed__)) sdshdr8 {
    <span style="color:#66d9ef">uint8_t</span> len; 
    <span style="color:#66d9ef">uint8_t</span> alloc; 
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> flags; 
    <span style="color:#66d9ef">char</span> buf[];
};
</code></pre></div><p>需要的字节数为1+1+1+7 = 10个字节。</p>
<p>那么，对于调用命令添加一个testKey，所需要的字节总数为16+24+10 = 50。</p>
<p>在设计key的过程中，应当避免key过长。</p>
<p>同时，redis针对这种由于key的字节长度引起的存储容量问题，有着自己的key删除策略和过期淘汰机制。</p>
<p>key删除策略和过期淘汰机制将会在后续的章节中展开分析。</p>
]]></content>
        </item>
        
        <item>
            <title>浮生如梦</title>
            <link>https://Huang-zh.github.io/posts/firstpost/</link>
            <pubDate>Thu, 24 Aug 2023 00:00:00 +0000</pubDate>
            
            <guid>https://Huang-zh.github.io/posts/firstpost/</guid>
            <description>午月间
安逸的人
情不禁的人
得意的人
忘形的人
悻悻而归的人
痴心的人
醉醺醺的人
神隐的人
驾五色龙船的人
将信疑的人
无我的人
喜乐的人
奔波游离的人
失约的人
摇摇晃的人
妙悟的人</description>
            <content type="html"><![CDATA[<p>午月间</p>
<p>安逸的人</p>
<p>情不禁的人</p>
<p>得意的人</p>
<p>忘形的人</p>
<p>悻悻而归的人</p>
<p>痴心的人</p>
<p>醉醺醺的人</p>
<p>神隐的人</p>
<p>驾五色龙船的人</p>
<p>将信疑的人</p>
<p>无我的人</p>
<p>喜乐的人</p>
<p>奔波游离的人</p>
<p>失约的人</p>
<p>摇摇晃的人</p>
<p>妙悟的人</p>
<!-- raw HTML omitted -->
]]></content>
        </item>
        
    </channel>
</rss>
